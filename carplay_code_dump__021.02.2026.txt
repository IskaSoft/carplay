lib/core/gps_service.dart

import 'dart:async';
import 'package:geolocator/geolocator.dart';
import 'package:carplay/models/location_point.dart';

class GpsService {
  GpsService._();
  static final GpsService instance = GpsService._();

  StreamSubscription<Position>? _subscription;

  // Single long-lived broadcast controller for the app lifetime.
  // Never closed so TripManager can re-subscribe on every new trip.
  final StreamController<LocationPoint> _controller =
      StreamController<LocationPoint>.broadcast();

  Stream<LocationPoint> get locationStream => _controller.stream;
  bool get isTracking => _subscription != null;

  static const LocationSettings _locationSettings = LocationSettings(
    accuracy: LocationAccuracy.bestForNavigation,
    distanceFilter: 0,
    timeLimit: null,
  );

  // ─── Public API ───────────────────────────────────────────────────────────

  /// Returns false if GPS service is disabled or permission denied.
  /// Returns true when streaming started successfully.
  Future<bool> start() async {
    // Cancel any existing subscription before starting fresh.
    // This is what makes NEW TRIP work correctly after STOP TRIP.
    if (_subscription != null) {
      await _subscription!.cancel();
      _subscription = null;
    }

    // FIX: Check GPS service BEFORE starting the stream.
    // Old code added errors to the controller immediately, but TripManager
    // had not yet called listen() at that point — errors were lost silently.
    // Now we return false so the caller (TripManager / dashboard) can react.
    final serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      return false; // Caller shows "GPS is turned off" dialog
    }

    final permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied ||
        permission == LocationPermission.deniedForever) {
      return false; // Caller shows permission dialog
    }

    _subscription = Geolocator.getPositionStream(
      locationSettings: _locationSettings,
    ).listen(
      (position) => _controller.add(_fromPosition(position)),
      onError: (Object e) {
        // GPS lost mid-trip (tunnel, signal lost) — emit error so
        // TripManager can set gpsSignalLost = true. Keep alive to recover.
        _controller.addError(e);
      },
      cancelOnError: false,
    );

    return true;
  }

  Future<void> stop() async {
    await _subscription?.cancel();
    _subscription = null;
    // Do NOT close _controller — it must stay open for the next trip.
  }

  Future<LocationPoint?> currentPosition() async {
    try {
      final p = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.bestForNavigation,
        timeLimit: const Duration(seconds: 10),
      );
      return _fromPosition(p);
    } catch (_) {
      return null;
    }
  }

  void dispose() {
    stop();
    _controller.close();
  }

  LocationPoint _fromPosition(Position p) {
    return LocationPoint(
      latitude: p.latitude,
      longitude: p.longitude,
      speedMs: p.speed,
      accuracy: p.accuracy,
      timestamp: p.timestamp,
      altitude: p.altitude,
    );
  }
}

------------------------------------

lib/core/speed_calculator.dart

import 'dart:math' as math;
import 'package:carplay/models/location_point.dart';

/// Pure calculation engine — no Flutter or platform dependencies.
class SpeedCalculator {
  SpeedCalculator._();

  static const double _earthRadiusMeters = 6371000.0;

  // ─── Haversine ────────────────────────────────────────────────────────────

  /// Returns distance in metres between two GPS coordinates.
  static double haversineDistance(LocationPoint a, LocationPoint b) {
    final lat1 = _toRad(a.latitude);
    final lat2 = _toRad(b.latitude);
    final dLat = _toRad(b.latitude - a.latitude);
    final dLon = _toRad(b.longitude - a.longitude);
    final sinDLat = math.sin(dLat / 2);
    final sinDLon = math.sin(dLon / 2);
    final h =
        sinDLat * sinDLat + math.cos(lat1) * math.cos(lat2) * sinDLon * sinDLon;
    return 2 * _earthRadiusMeters * math.asin(math.sqrt(h));
  }

  // ─── Speed ────────────────────────────────────────────────────────────────

  // FIX: Restore GPS chipset Doppler speed as primary source.
  //
  // Your previous version (haversine-only) had two problems:
  //
  // 1. PHANTOM SPEED WHEN STATIONARY: Even a parked phone drifts 2–5 metres
  //    between GPS fixes. With 1-second updates, haversine gives 7–18 km/h
  //    when you are completely still. The chipset Doppler never does this —
  //    it reads ~0.0 m/s when stationary.
  //
  // 2. WRONG AVERAGE SPEED: Because haversine reported phantom speed while
  //    stopped (red lights, parking), average speed was inflated the entire
  //    trip — sometimes by 10–20 km/h on city drives.
  //
  // GPS chipset Doppler is accurate to ±0.05 m/s even at walking speed.
  // Haversine is kept as fallback only for old chipsets that return speedMs < 0.
  static double computeCurrentSpeedKmh(
    LocationPoint point, {
    LocationPoint? previous,
  }) {
    // ✅ PRIMARY: GPS chipset Doppler speed — accurate, noise-free at stops
    if (point.hasValidSpeed && point.isAccurate) {
      return point.speedKmh;
    }

    // ✅ FALLBACK: haversine Δdist/Δt only when chipset speed unavailable
    if (previous != null) {
      final distM = haversineDistance(previous, point);
      final dtSec =
          point.timestamp
              .difference(previous.timestamp)
              .inMilliseconds
              .toDouble() /
          1000.0;
      if (dtSec > 0.1 && dtSec < 10.0) {
        return (distM / dtSec) * 3.6;
      }
    }

    return 0.0;
  }

  /// averageSpeed = totalDistance / movingTime
  static double computeAverageSpeedKmh(
    double totalDistanceMeters,
    int movingTimeSeconds,
  ) {
    if (movingTimeSeconds <= 0) return 0.0;
    return (totalDistanceMeters / movingTimeSeconds) * 3.6;
  }

  // ─── Unit conversion ──────────────────────────────────────────────────────

  static double kmhToMph(double kmh) => kmh * 0.621371;
  static double metersToMiles(double m) => m / 1609.344;
  static double metersToKm(double m) => m / 1000.0;

  // ─── Noise filter ─────────────────────────────────────────────────────────

  /// Returns true when the fix should be accepted for distance accumulation.
  static bool shouldAcceptFix(LocationPoint fix, {LocationPoint? previous}) {
    if (!fix.isAccurate) return false;
    if (previous == null) return true;
    final distM = haversineDistance(previous, fix);
    final dtSec =
        fix.timestamp.difference(previous.timestamp).inMilliseconds / 1000.0;
    if (dtSec <= 0) return false;
    // Reject GPS glitches (> 300 km/h implied speed between two fixes)
    final impliedSpeedKmh = (distM / dtSec) * 3.6;
    if (impliedSpeedKmh > 300) return false;
    return true;
  }

  static double _toRad(double deg) => deg * math.pi / 180.0;
}

------------------------------------

lib/core/trip_manager.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:carplay/models/location_point.dart';
import 'package:carplay/models/trip_data.dart';
import 'package:carplay/core/speed_calculator.dart';
import 'package:carplay/core/gps_service.dart';

class TripState with ChangeNotifier {
  TripState._();
  static final TripState instance = TripState._();

  // ─── Live fields ──────────────────────────────────────────────────────────

  TripStatus status = TripStatus.idle;
  double currentSpeedKmh = 0;
  double averageSpeedKmh = 0;
  double totalDistanceMeters = 0;
  double maxSpeedKmh = 0;
  int movingTimeSeconds = 0;
  DateTime? tripStartTime;
  DateTime? pauseStartTime;
  LocationPoint? lastPoint;
  bool gpsSignalLost = false;

  bool autoStart = false;

  // ─── Internal ─────────────────────────────────────────────────────────────

  StreamSubscription<LocationPoint>? _gpsSub;
  Timer? _clockTimer;
  int _pausedSeconds = 0;

  // ─── Computed ─────────────────────────────────────────────────────────────

  int get elapsedSeconds {
    if (tripStartTime == null) return 0;
    final raw = DateTime.now().difference(tripStartTime!).inSeconds;
    return raw - _pausedSeconds;
  }

  String get formattedElapsed {
    final s = elapsedSeconds;
    final h = s ~/ 3600;
    final m = (s % 3600) ~/ 60;
    final sec = s % 60;
    if (h > 0) return '${h}h ${m.toString().padLeft(2, '0')}m';
    return '${m.toString().padLeft(2, '0')}:${sec.toString().padLeft(2, '0')}';
  }

  double get distanceKm => totalDistanceMeters / 1000.0;
  double get distanceMiles => totalDistanceMeters / 1609.344;

  // ─── Public control ───────────────────────────────────────────────────────

  /// Returns true if trip started successfully, false if GPS unavailable.
  Future<bool> startTrip() async {
    if (status == TripStatus.driving) return true;

    _reset();

    // FIX: Cancel any leftover GPS listener from previous trip BEFORE
    // starting a new one. This is what makes NEW TRIP work correctly.
    await _gpsSub?.cancel();
    _gpsSub = null;

    // FIX: GpsService.start() now returns bool.
    // If GPS is off or permission denied, abort cleanly — stay in idle state
    // so the dashboard can show the correct dialog to the user.
    final gpsStarted = await GpsService.instance.start();
    if (!gpsStarted) {
      gpsSignalLost = true;
      notifyListeners();
      return false; // Dashboard will show GPS disabled dialog
    }

    status = TripStatus.driving;
    tripStartTime = DateTime.now();
    gpsSignalLost = false;

    // Subscribe to the GPS broadcast stream
    _gpsSub = GpsService.instance.locationStream.listen(
      _onGpsFix,
      onError: _onGpsError,
    );

    _clockTimer?.cancel();
    _clockTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      if (status == TripStatus.driving) {
        movingTimeSeconds++;
        notifyListeners();
      }
    });

    notifyListeners();
    return true;
  }

  void pauseTrip() {
    if (status != TripStatus.driving) return;
    status = TripStatus.paused;
    pauseStartTime = DateTime.now();
    notifyListeners();
  }

  void resumeTrip() {
    if (status != TripStatus.paused) return;
    if (pauseStartTime != null) {
      _pausedSeconds += DateTime.now().difference(pauseStartTime!).inSeconds;
    }
    pauseStartTime = null;
    status = TripStatus.driving;
    notifyListeners();
  }

  Future<TripData?> stopTrip() async {
    if (status == TripStatus.idle) return null;

    status = TripStatus.stopped;
    _clockTimer?.cancel();
    _clockTimer = null;

    await _gpsSub?.cancel();
    _gpsSub = null;

    await GpsService.instance.stop();

    final trip = TripData(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      startTime: tripStartTime ?? DateTime.now(),
      endTime: DateTime.now(),
      totalDistanceMeters: totalDistanceMeters,
      averageSpeedKmh: averageSpeedKmh,
      maxSpeedKmh: maxSpeedKmh,
      durationSeconds: elapsedSeconds,
      stateIndex: 'stopped',
    );

    final box = Hive.box<TripData>('trips');
    await box.add(trip);

    _reset();
    notifyListeners();
    return trip;
  }

  // ─── GPS processing ───────────────────────────────────────────────────────

  void _onGpsFix(LocationPoint fix) {
    gpsSignalLost = false;

    final speedKmh = SpeedCalculator.computeCurrentSpeedKmh(
      fix,
      previous: lastPoint,
    );
    currentSpeedKmh = speedKmh;
    if (speedKmh > maxSpeedKmh) maxSpeedKmh = speedKmh;

    // Auto-start
    if (status == TripStatus.idle && autoStart && speedKmh > 10.0) {
      startTrip();
      return;
    }

    // Accumulate distance when driving
    if (status == TripStatus.driving) {
      if (lastPoint != null &&
          SpeedCalculator.shouldAcceptFix(fix, previous: lastPoint)) {
        final d = SpeedCalculator.haversineDistance(lastPoint!, fix);
        if (d > 3) totalDistanceMeters += d;
      }

      averageSpeedKmh = SpeedCalculator.computeAverageSpeedKmh(
        totalDistanceMeters,
        movingTimeSeconds,
      );
    }

    lastPoint = fix;
    notifyListeners();
  }

  void _onGpsError(Object error) {
    gpsSignalLost = true;
    notifyListeners();
  }

  // ─── Private ──────────────────────────────────────────────────────────────

  void _reset() {
    currentSpeedKmh = 0;
    averageSpeedKmh = 0;
    totalDistanceMeters = 0;
    maxSpeedKmh = 0;
    movingTimeSeconds = 0;
    _pausedSeconds = 0;
    tripStartTime = null;
    pauseStartTime = null;
    lastPoint = null;
    gpsSignalLost = false;
  }
}

enum TripStatus { idle, driving, paused, stopped }

------------------------------------

lib/main.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:provider/provider.dart';

import 'package:carplay/core/trip_manager.dart';
import 'package:carplay/models/location_point.dart';
import 'package:carplay/models/trip_data.dart';
import 'package:carplay/services/background_service.dart';
import 'package:carplay/ui/dashboard_screen.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // ── Hive setup ────────────────────────────────────────────────────────────
  await Hive.initFlutter();

  // FIX: Guard adapter registration with isAdapterRegistered checks.
  // Without these guards, if Android restarts the isolate after 5+ hours
  // (low memory, battery saver, etc.) and main() runs again, Hive throws
  // "Adapter already registered" → Hive re-inits to a bad state → data lost.
  if (!Hive.isAdapterRegistered(0)) {
    Hive.registerAdapter(LocationPointAdapter());
  }
  if (!Hive.isAdapterRegistered(1)) {
    Hive.registerAdapter(TripDataAdapter());
  }

  await Hive.openBox<TripData>('trips');
  await Hive.openBox('settings');

  // FIX: Load persisted settings into TripState at launch.
  // Previously autoStart was never restored after an app restart.
  final settingsBox = Hive.box('settings');
  TripState.instance.autoStart =
      settingsBox.get('autoStart', defaultValue: false) as bool;

  // ── Background service ───────────────────────────────────────────────────
  await BackgroundServiceManager.initialize();

  // ── System UI ────────────────────────────────────────────────────────────
  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.light,
    ),
  );

  runApp(
    ChangeNotifierProvider.value(
      value: TripState.instance,
      child: const CarPlayApp(),
    ),
  );
}

class CarPlayApp extends StatelessWidget {
  const CarPlayApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'CarPlay',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        brightness: Brightness.dark,
        scaffoldBackgroundColor: const Color(0xFF0A0A0F),
        colorScheme: const ColorScheme.dark(
          primary: Color(0xFF00E676),
          surface: Color(0xFF12121E),
        ),
        fontFamily: 'SF Pro Display',
        useMaterial3: true,
      ),
      home: const DashboardScreen(),
    );
  }
}

------------------------------------

lib/models/location_point.dart

// import 'package:hive/hive.dart';

// part 'package:carplay/models/location_point.g.dart';

// /// A single GPS fix captured during a trip.
// /// speedMs comes directly from the GPS chipset via geolocator.
// @HiveType(typeId: 0)
// class LocationPoint extends HiveObject {
//   @HiveField(0)
//   final double latitude;

//   @HiveField(1)
//   final double longitude;

//   @HiveField(2)
//   final double speedMs; // m/s as reported by GPS hardware

//   @HiveField(3)
//   final double accuracy; // horizontal accuracy in metres

//   @HiveField(4)
//   final DateTime timestamp;

//   @HiveField(5)
//   final double altitude;

//   LocationPoint({
//     required this.latitude,
//     required this.longitude,
//     required this.speedMs,
//     required this.accuracy,
//     required this.timestamp,
//     this.altitude = 0.0,
//   });

//   double get speedKmh => speedMs >= 0 ? speedMs * 3.6 : 0.0;
//   double get speedMph => speedMs >= 0 ? speedMs * 2.23694 : 0.0;

//   bool get hasValidSpeed => speedMs >= 0;
//   bool get isAccurate => accuracy <= 10.0;

//   @override
//   String toString() =>
//       'LocationPoint(${speedKmh.toStringAsFixed(1)} km/h, acc ${accuracy.toStringAsFixed(0)} m)';
// }

import 'package:hive/hive.dart';

part 'location_point.g.dart';

/// A single GPS fix captured during a trip.
/// speedMs comes directly from the GPS chipset via geolocator.
@HiveType(typeId: 0)
class LocationPoint extends HiveObject {
  @HiveField(0)
  final double latitude;

  @HiveField(1)
  final double longitude;

  @HiveField(2)
  final double speedMs; // m/s as reported by GPS hardware

  @HiveField(3)
  final double accuracy; // horizontal accuracy in metres

  @HiveField(4)
  final DateTime timestamp;

  @HiveField(5)
  final double altitude;

  LocationPoint({
    required this.latitude,
    required this.longitude,
    required this.speedMs,
    required this.accuracy,
    required this.timestamp,
    this.altitude = 0.0,
  });

  double get speedKmh => speedMs >= 0 ? speedMs * 3.6 : 0.0;
  double get speedMph => speedMs >= 0 ? speedMs * 2.23694 : 0.0;

  bool get hasValidSpeed => speedMs >= 0;

  // FIX: Changed from 10.0 → 25.0 metres.
  // The old 10m threshold was far too strict. In urban areas most Android
  // phones report 12–20m accuracy even with a clear sky. With 10m, almost
  // every fix was rejected → shouldAcceptFix always returned false →
  // distance never accumulated and speed fell back to noisy haversine only.
  // 25m is the industry-standard threshold used by Google Maps and Waze.
  bool get isAccurate => accuracy <= 25.0;

  @override
  String toString() =>
      'LocationPoint(${speedKmh.toStringAsFixed(1)} km/h, acc ${accuracy.toStringAsFixed(0)} m)';
}

------------------------------------

lib/models/location_point.g.dart

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'location_point.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class LocationPointAdapter extends TypeAdapter<LocationPoint> {
  @override
  final int typeId = 0;

  @override
  LocationPoint read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return LocationPoint(
      latitude: fields[0] as double,
      longitude: fields[1] as double,
      speedMs: fields[2] as double,
      accuracy: fields[3] as double,
      timestamp: fields[4] as DateTime,
      altitude: fields[5] as double,
    );
  }

  @override
  void write(BinaryWriter writer, LocationPoint obj) {
    writer
      ..writeByte(6)
      ..writeByte(0)
      ..write(obj.latitude)
      ..writeByte(1)
      ..write(obj.longitude)
      ..writeByte(2)
      ..write(obj.speedMs)
      ..writeByte(3)
      ..write(obj.accuracy)
      ..writeByte(4)
      ..write(obj.timestamp)
      ..writeByte(5)
      ..write(obj.altitude);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocationPointAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

------------------------------------

lib/models/trip_data.dart

import 'package:hive/hive.dart';

part 'trip_data.g.dart';

enum TripStatus { idle, driving, paused, stopped }

/// Immutable summary stored after each trip completes.
@HiveType(typeId: 1)
class TripData extends HiveObject {
  @HiveField(0)
  final String id;

  @HiveField(1)
  final DateTime startTime;

  @HiveField(2)
  final DateTime? endTime;

  @HiveField(3)
  final double totalDistanceMeters;

  @HiveField(4)
  final double averageSpeedKmh;

  @HiveField(5)
  final double maxSpeedKmh;

  @HiveField(6)
  final int durationSeconds;

  @HiveField(7)
  final String stateIndex; // stored as string for portability

  TripData({
    required this.id,
    required this.startTime,
    this.endTime,
    required this.totalDistanceMeters,
    required this.averageSpeedKmh,
    required this.maxSpeedKmh,
    required this.durationSeconds,
    required this.stateIndex,
  });

  double get totalDistanceKm => totalDistanceMeters / 1000.0;
  double get totalDistanceMiles => totalDistanceMeters / 1609.344;

  String get formattedDuration {
    final h = durationSeconds ~/ 3600;
    final m = (durationSeconds % 3600) ~/ 60;
    final s = durationSeconds % 60;
    if (h > 0) return '${h}h ${m.toString().padLeft(2, '0')}m';
    return '${m}m ${s.toString().padLeft(2, '0')}s';
  }

  TripData copyWith({
    DateTime? endTime,
    double? totalDistanceMeters,
    double? averageSpeedKmh,
    double? maxSpeedKmh,
    int? durationSeconds,
    String? stateIndex,
  }) {
    return TripData(
      id: id,
      startTime: startTime,
      endTime: endTime ?? this.endTime,
      totalDistanceMeters: totalDistanceMeters ?? this.totalDistanceMeters,
      averageSpeedKmh: averageSpeedKmh ?? this.averageSpeedKmh,
      maxSpeedKmh: maxSpeedKmh ?? this.maxSpeedKmh,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      stateIndex: stateIndex ?? this.stateIndex,
    );
  }
}

------------------------------------

lib/models/trip_data.g.dart

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'trip_data.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TripDataAdapter extends TypeAdapter<TripData> {
  @override
  final int typeId = 1;

  @override
  TripData read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TripData(
      id: fields[0] as String,
      startTime: fields[1] as DateTime,
      endTime: fields[2] as DateTime?,
      totalDistanceMeters: fields[3] as double,
      averageSpeedKmh: fields[4] as double,
      maxSpeedKmh: fields[5] as double,
      durationSeconds: fields[6] as int,
      stateIndex: fields[7] as String,
    );
  }

  @override
  void write(BinaryWriter writer, TripData obj) {
    writer
      ..writeByte(8)
      ..writeByte(0)
      ..write(obj.id)
      ..writeByte(1)
      ..write(obj.startTime)
      ..writeByte(2)
      ..write(obj.endTime)
      ..writeByte(3)
      ..write(obj.totalDistanceMeters)
      ..writeByte(4)
      ..write(obj.averageSpeedKmh)
      ..writeByte(5)
      ..write(obj.maxSpeedKmh)
      ..writeByte(6)
      ..write(obj.durationSeconds)
      ..writeByte(7)
      ..write(obj.stateIndex);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TripDataAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

------------------------------------

lib/platform_bridge/car_data_sender.dart

import 'package:flutter/services.dart';

/// One-way bridge: Flutter → Native car display.
///
/// The native side (Android Auto / CarPlay) registers a MethodChannel handler
/// that receives speed data and refreshes the car UI template.
///
/// Channel name must match exactly in Kotlin and Swift.
class CarDataSender {
  CarDataSender._();
  static final CarDataSender instance = CarDataSender._();

  static const MethodChannel _channel = MethodChannel(
    'com.example.carplay/car_display',
  );

  // Received from background service or TripState
  Future<void> sendUpdate({
    required double currentSpeedKmh,
    required double averageSpeedKmh,
    required double totalDistanceMeters,
    required int movingTimeSeconds,
    required String tripStatus, // "idle" | "driving" | "paused" | "stopped"
    bool useImperial = false,
  }) async {
    try {
      await _channel.invokeMethod('updateDisplay', {
        'currentSpeedKmh': currentSpeedKmh,
        'averageSpeedKmh': averageSpeedKmh,
        'totalDistanceMeters': totalDistanceMeters,
        'movingTimeSeconds': movingTimeSeconds,
        'tripStatus': tripStatus,
        'useImperial': useImperial,
        // Pre-converted values the native layer can display directly
        'currentSpeedDisplay':
            useImperial
                ? (currentSpeedKmh * 0.621371).toStringAsFixed(0)
                : currentSpeedKmh.toStringAsFixed(0),
        'averageSpeedDisplay':
            useImperial
                ? (averageSpeedKmh * 0.621371).toStringAsFixed(0)
                : averageSpeedKmh.toStringAsFixed(0),
        'speedUnit': useImperial ? 'mph' : 'km/h',
        'distanceDisplay':
            useImperial
                ? '${(totalDistanceMeters / 1609.344).toStringAsFixed(2)} mi'
                : '${(totalDistanceMeters / 1000).toStringAsFixed(2)} km',
        'durationDisplay': _formatDuration(movingTimeSeconds),
      });
    } on PlatformException catch (e) {
      // Car display not connected — safe to ignore
      debugPrint('CarDataSender: PlatformException ${e.message}');
    } on MissingPluginException {
      // Running on simulator without native car library — safe to ignore
    }
  }

  static String _formatDuration(int seconds) {
    final h = seconds ~/ 3600;
    final m = (seconds % 3600) ~/ 60;
    final s = seconds % 60;
    if (h > 0) return '${h}h ${m.toString().padLeft(2, '0')}m';
    return '${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}';
  }
}

// ignore: avoid_print
void debugPrint(String msg) => print('[Average] $msg');

------------------------------------

lib/services/background_service.dart

import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:carplay/core/gps_service.dart';
import 'package:carplay/core/speed_calculator.dart';
import 'package:carplay/core/trip_manager.dart';
import 'package:carplay/models/location_point.dart';
import 'package:carplay/models/trip_data.dart';

/// Bootstraps flutter_background_service so tracking persists when the
/// phone screen turns off or the user switches apps.
///
/// Architecture:
///   Main isolate  ←→  Background isolate (this file)
///   The background isolate owns the GPS stream and TripState.
///   It broadcasts updates to the main isolate via ServiceInstance events.
class BackgroundServiceManager {
  static const String _channelId = 'com.example.carplay.tracking';
  static const String _channelName = 'CarPlay – Speed Tracking';

  static Future<void> initialize() async {
    final service = FlutterBackgroundService();

    await service.configure(
      // ── Android: foreground service with persistent notification ──────────
      androidConfiguration: AndroidConfiguration(
        onStart: _onStart,
        isForegroundMode: true,
        autoStart: false,
        notificationChannelId: _channelId,
        initialNotificationTitle: 'CarPlay',
        initialNotificationContent: 'Speed tracking active',
        foregroundServiceNotificationId: 888,
        foregroundServiceTypes: [AndroidForegroundType.location],
      ),
      // ── iOS: background fetch + location ─────────────────────────────────
      iosConfiguration: IosConfiguration(
        onForeground: _onStart,
        onBackground: _onIosBackground,
        autoStart: false,
      ),
    );
  }

  static Future<bool> start() => FlutterBackgroundService().startService();
  static Future<bool> isRunning() => FlutterBackgroundService().isRunning();

  static void stop() => FlutterBackgroundService().invoke('stopService');

  /// Send a command to the background isolate.
  static void send(String event, [Map<String, dynamic>? data]) =>
      FlutterBackgroundService().invoke(event, data);

  // ─── Background isolate entry point ──────────────────────────────────────

  @pragma('vm:entry-point')
  static Future<void> _onStart(ServiceInstance service) async {
    DartPluginRegistrant.ensureInitialized();

    // Re-open Hive in the background isolate
    await Hive.initFlutter();
    if (!Hive.isAdapterRegistered(0)) {
      Hive.registerAdapter(LocationPointAdapter());
    }
    if (!Hive.isAdapterRegistered(1)) {
      Hive.registerAdapter(TripDataAdapter());
    }
    await Hive.openBox<TripData>('trips');

    // Local state for this isolate
    double totalDistanceMeters = 0;
    double currentSpeedKmh = 0;
    double averageSpeedKmh = 0;
    int movingTimeSeconds = 0;
    double maxSpeedKmh = 0;
    LocationPoint? lastPoint;
    bool isActive = false;

    // ── Listen for commands from main isolate ─────────────────────────────
    service.on('start').listen((_) async {
      isActive = true;
      totalDistanceMeters = 0;
      currentSpeedKmh = 0;
      averageSpeedKmh = 0;
      movingTimeSeconds = 0;
      maxSpeedKmh = 0;
      lastPoint = null;
      await GpsService.instance.start();
    });

    service.on('stop').listen((_) async {
      isActive = false;
      await GpsService.instance.stop();
      service.invoke('stopped', {});
    });

    service.on('stopService').listen((_) async {
      await GpsService.instance.stop();
      service.stopSelf();
    });

    // ── GPS stream ────────────────────────────────────────────────────────
    Timer? clockTimer;
    clockTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      if (isActive) movingTimeSeconds++;
    });

    GpsService.instance.locationStream.listen((fix) {
      if (!isActive) return;

      currentSpeedKmh = SpeedCalculator.computeCurrentSpeedKmh(
        fix,
        previous: lastPoint,
      );
      if (currentSpeedKmh > maxSpeedKmh) maxSpeedKmh = currentSpeedKmh;

      if (lastPoint != null &&
          SpeedCalculator.shouldAcceptFix(fix, previous: lastPoint)) {
        totalDistanceMeters += SpeedCalculator.haversineDistance(
          lastPoint!,
          fix,
        );
      }

      averageSpeedKmh = SpeedCalculator.computeAverageSpeedKmh(
        totalDistanceMeters,
        movingTimeSeconds,
      );

      lastPoint = fix;

      // Broadcast to main isolate & car displays
      service.invoke('update', {
        'currentSpeedKmh': currentSpeedKmh,
        'averageSpeedKmh': averageSpeedKmh,
        'totalDistanceMeters': totalDistanceMeters,
        'movingTimeSeconds': movingTimeSeconds,
        'maxSpeedKmh': maxSpeedKmh,
        'lat': fix.latitude,
        'lng': fix.longitude,
        'accuracy': fix.accuracy,
      });

      // Update foreground notification
      if (service is AndroidServiceInstance) {
        service.setForegroundNotificationInfo(
          title: 'Average – ${currentSpeedKmh.toStringAsFixed(0)} km/h',
          content:
              'Avg ${averageSpeedKmh.toStringAsFixed(0)} km/h · ${(totalDistanceMeters / 1000).toStringAsFixed(2)} km',
        );
      }
    });
  }

  @pragma('vm:entry-point')
  static Future<bool> _onIosBackground(ServiceInstance service) async {
    WidgetsFlutterBinding.ensureInitialized();
    DartPluginRegistrant.ensureInitialized();
    return true;
  }
}

------------------------------------

lib/services/permission_service.dart

import 'package:permission_handler/permission_handler.dart';

/// Handles all runtime permission requests for the app.
class PermissionService {
  PermissionService._();
  static final PermissionService instance = PermissionService._();

  /// Returns true only when ALL required permissions are granted.
  Future<bool> requestAll() async {
    // Always-while-driving requires background location
    final results = await [
      Permission.location,
      Permission.locationAlways,
      Permission.notification, // required for foreground service on Android 13+
    ].request();

    final locationOk = results[Permission.location] == PermissionStatus.granted;
    final bgOk = results[Permission.locationAlways] == PermissionStatus.granted;

    return locationOk && bgOk;
  }

  Future<bool> hasLocationPermission() async {
    final status = await Permission.location.status;
    return status == PermissionStatus.granted;
  }

  Future<bool> hasBackgroundLocationPermission() async {
    final status = await Permission.locationAlways.status;
    return status == PermissionStatus.granted;
  }

  Future<bool> isLocationServiceEnabled() async {
    return Permission.location.serviceStatus.then(
      (s) => s == ServiceStatus.enabled,
    );
  }

  Future<void> openSettings() => openAppSettings();
}

------------------------------------

lib/ui/dashboard_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:provider/provider.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import 'package:carplay/core/trip_manager.dart';
import 'package:carplay/platform_bridge/car_data_sender.dart';
import 'package:carplay/services/permission_service.dart';
import 'package:carplay/ui/settings_screen.dart';
import 'package:carplay/ui/trip_screen.dart';
import 'package:carplay/ui/widgets/speed_gauge.dart';
import 'package:carplay/ui/widgets/stat_card.dart';
import 'package:carplay/ui/widgets/gps_status_bar.dart';

class DashboardScreen extends StatefulWidget {
  const DashboardScreen({super.key});

  @override
  State<DashboardScreen> createState() => _DashboardScreenState();
}

class _DashboardScreenState extends State<DashboardScreen>
    with WidgetsBindingObserver {
  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    SystemChrome.setPreferredOrientations([
      DeviceOrientation.portraitUp,
      DeviceOrientation.landscapeLeft,
      DeviceOrientation.landscapeRight,
    ]);
    _checkPermissions();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    WakelockPlus.disable();
    super.dispose();
  }

  Future<void> _checkPermissions() async {
    final ok = await PermissionService.instance.hasLocationPermission();
    if (!ok && mounted) _showPermissionDialog();
  }

  void _showPermissionDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder:
          (_) => AlertDialog(
            backgroundColor: const Color(0xFF12121E),
            title: const Text(
              'Location Permission Required',
              style: TextStyle(color: Colors.white),
            ),
            content: const Text(
              'This app needs location permission to track speed and distance.\n\n'
              'Please allow "All the time" access for background tracking.',
              style: TextStyle(color: Colors.white70),
            ),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.pop(context);
                  PermissionService.instance.requestAll();
                },
                child: const Text(
                  'Grant Permission',
                  style: TextStyle(color: Color(0xFF00E676)),
                ),
              ),
              TextButton(
                onPressed: () {
                  Navigator.pop(context);
                  PermissionService.instance.openSettings();
                },
                child: const Text(
                  'Open Settings',
                  style: TextStyle(color: Colors.white54),
                ),
              ),
            ],
          ),
    );
  }

  // Shows dialog when GPS (location service) is disabled on the phone
  void _showGpsDisabledDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder:
          (_) => AlertDialog(
            backgroundColor: const Color(0xFF12121E),
            title: const Text(
              'GPS is Turned Off',
              style: TextStyle(color: Colors.white),
            ),
            content: const Text(
              'Please turn on GPS (Location) in your phone settings to track your trip.',
              style: TextStyle(color: Colors.white70),
            ),
            actions: [
              TextButton(
                onPressed: () {
                  Navigator.pop(context);
                  // Opens the phone's location settings page
                  PermissionService.instance.openSettings();
                },
                child: const Text(
                  'Open Location Settings',
                  style: TextStyle(color: Color(0xFF00E676)),
                ),
              ),
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: const Text(
                  'Cancel',
                  style: TextStyle(color: Colors.white54),
                ),
              ),
            ],
          ),
    );
  }

  Future<void> _toggleTrip(TripState trip) async {
    if (trip.status == TripStatus.idle || trip.status == TripStatus.stopped) {
      // Check location permission first
      final hasPermission =
          await PermissionService.instance.hasLocationPermission();
      if (!hasPermission) {
        if (mounted) _showPermissionDialog();
        return;
      }

      // Check GPS service (is location turned on in phone settings?)
      final gpsEnabled =
          await PermissionService.instance.isLocationServiceEnabled();
      if (!gpsEnabled) {
        if (mounted) _showGpsDisabledDialog();
        return;
      }

      await WakelockPlus.enable();
      final started = await trip.startTrip();
      if (!started) {
        await WakelockPlus.disable();
        // GPS service check already showed dialog above, but startTrip()
        // does a second internal check — show GPS dialog as safety net
        if (mounted) _showGpsDisabledDialog();
      }
    } else if (trip.status == TripStatus.driving) {
      final result = await trip.stopTrip();
      await WakelockPlus.disable();
      if (result != null && mounted) {
        Navigator.push(
          context,
          MaterialPageRoute(builder: (_) => TripScreen(trip: result)),
        );
      }
    } else if (trip.status == TripStatus.paused) {
      trip.resumeTrip();
    }
  }

  void _pauseTrip(TripState trip) {
    trip.pauseTrip();
  }

  @override
  Widget build(BuildContext context) {
    // FIX: Wrap with ValueListenableBuilder on the Hive settings box.
    // This makes the dashboard rebuild INSTANTLY when the toggle changes —
    // no need to come back from Settings, no restart required.
    return ValueListenableBuilder(
      valueListenable: Hive.box('settings').listenable(),
      builder: (context, Box settingsBox, _) {
        final useImperial =
            settingsBox.get('useImperial', defaultValue: false) as bool;
        return Consumer<TripState>(
          builder: (context, trip, _) {
            return _buildScaffold(context, trip, useImperial);
          },
        );
      },
    );
  }

  Widget _buildScaffold(
    BuildContext context,
    TripState trip,
    bool useImperial,
  ) {
    // Send to Android Auto on every state update
    CarDataSender.instance.sendUpdate(
      currentSpeedKmh: trip.currentSpeedKmh,
      averageSpeedKmh: trip.averageSpeedKmh,
      totalDistanceMeters: trip.totalDistanceMeters,
      movingTimeSeconds: trip.movingTimeSeconds,
      tripStatus: trip.status.name,
      useImperial: useImperial,
    );

    return Scaffold(
      backgroundColor: const Color(0xFF0A0A0F),
      appBar: _buildAppBar(context, trip),
      body: SafeArea(
        child: Column(
          children: [
            GpsStatusBar(
              isLost: trip.gpsSignalLost,
              isTracking:
                  (trip.status == TripStatus.driving ||
                      trip.status == TripStatus.paused) &&
                  !trip.gpsSignalLost,
            ),
            Expanded(child: _buildBody(context, trip, useImperial)),
            const SizedBox(height: 24),
            _buildControls(context, trip),
            const SizedBox(height: 32),
          ],
        ),
      ),
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, TripState trip) {
    return AppBar(
      backgroundColor: const Color(0xFF0A0A0F),
      elevation: 0,
      title: Row(
        children: [
          const Text(
            'CarPlay',
            style: TextStyle(
              color: Colors.white,
              fontSize: 20,
              fontWeight: FontWeight.w300,
              letterSpacing: 3,
            ),
          ),
          const SizedBox(width: 8),
          if (trip.status == TripStatus.driving)
            Container(
              width: 8,
              height: 8,
              decoration: const BoxDecoration(
                color: Color(0xFF00E676),
                shape: BoxShape.circle,
              ),
            ),
        ],
      ),
      actions: [
        IconButton(
          icon: const Icon(Icons.history_rounded, color: Colors.white54),
          onPressed:
              () => Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const TripHistoryScreen()),
              ),
        ),
        IconButton(
          icon: const Icon(Icons.settings_outlined, color: Colors.white54),
          onPressed:
              () => Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const SettingsScreen()),
              ),
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, TripState trip, bool useImperial) {
    final speed =
        useImperial ? (trip.currentSpeedKmh * 0.621371) : trip.currentSpeedKmh;
    final unit = useImperial ? 'mph' : 'km/h';

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          SpeedGauge(speedValue: speed, unit: unit),
          const SizedBox(height: 48),
          Row(
            children: [
              Expanded(
                child: StatCard(
                  label: 'AVG SPEED',
                  value:
                      useImperial
                          ? (trip.averageSpeedKmh * 0.621371).toStringAsFixed(1)
                          : trip.averageSpeedKmh.toStringAsFixed(1),
                  unit: unit,
                  icon: Icons.show_chart_rounded,
                  color: const Color(0xFF64B5F6),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: StatCard(
                  label: 'DISTANCE',
                  value:
                      useImperial
                          ? (trip.totalDistanceMeters / 1609.344)
                              .toStringAsFixed(2)
                          : (trip.totalDistanceMeters / 1000).toStringAsFixed(
                            2,
                          ),
                  unit: useImperial ? 'mi' : 'km',
                  icon: Icons.straighten_rounded,
                  color: const Color(0xFFFFB74D),
                ),
              ),
            ],
          ),
          const SizedBox(height: 12),
          Row(
            children: [
              Expanded(
                child: StatCard(
                  label: 'DURATION',
                  value: trip.formattedElapsed,
                  unit: '',
                  icon: Icons.timer_outlined,
                  color: const Color(0xFFCE93D8),
                  isTime: true,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: StatCard(
                  label: 'MAX SPEED',
                  value:
                      useImperial
                          ? (trip.maxSpeedKmh * 0.621371).toStringAsFixed(1)
                          : trip.maxSpeedKmh.toStringAsFixed(1),
                  unit: unit,
                  icon: Icons.speed_rounded,
                  color: const Color(0xFFEF9A9A),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildControls(BuildContext context, TripState trip) {
    final isDriving = trip.status == TripStatus.driving;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 24),
      child: Row(
        children: [
          AnimatedOpacity(
            opacity: isDriving ? 1.0 : 0.0,
            duration: const Duration(milliseconds: 300),
            child: GestureDetector(
              onTap: isDriving ? () => _pauseTrip(trip) : null,
              child: Container(
                width: 56,
                height: 56,
                decoration: BoxDecoration(
                  color: const Color(0xFF1C1C2E),
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: Colors.white12),
                ),
                child: const Icon(
                  Icons.pause_rounded,
                  color: Colors.white70,
                  size: 28,
                ),
              ),
            ),
          ),
          if (isDriving) const SizedBox(width: 12),
          Expanded(
            child: _TripButton(
              status: trip.status,
              onTap: () => _toggleTrip(trip),
            ),
          ),
        ],
      ),
    );
  }
}

// ─── Trip Button ──────────────────────────────────────────────────────────────

class _TripButton extends StatelessWidget {
  const _TripButton({required this.status, required this.onTap});

  final TripStatus status;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final (label, color, icon) = switch (status) {
      TripStatus.idle => (
        'START TRIP',
        const Color(0xFF00E676),
        Icons.play_arrow_rounded,
      ),
      TripStatus.driving => (
        'STOP TRIP',
        const Color(0xFFEF5350),
        Icons.stop_rounded,
      ),
      TripStatus.paused => (
        'RESUME',
        const Color(0xFFFFB74D),
        Icons.play_arrow_rounded,
      ),
      TripStatus.stopped => (
        'NEW TRIP',
        const Color(0xFF00E676),
        Icons.play_arrow_rounded,
      ),
    };

    return GestureDetector(
      onTap: onTap,
      child: Container(
        height: 56,
        decoration: BoxDecoration(
          color: color.withOpacity(0.15),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: color.withOpacity(0.6), width: 1.5),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, color: color, size: 22),
            const SizedBox(width: 10),
            Text(
              label,
              style: TextStyle(
                color: color,
                fontSize: 15,
                fontWeight: FontWeight.w600,
                letterSpacing: 1.5,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

------------------------------------

lib/ui/settings_screen.dart

import 'package:flutter/material.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:carplay/core/trip_manager.dart';

class SettingsScreen extends StatefulWidget {
  // FIX: Remove initialImperial parameter entirely.
  // It was the root cause of the toggle resetting — dashboard passed false
  // every time (because _useImperial in dashboard was never loaded from Hive),
  // then _loadSettings() read the correct value from Hive but immediately
  // overwrote it with widget.initialImperial (which was always false).
  // Now SettingsScreen reads directly from Hive — single source of truth.
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  late bool _useImperial;
  late bool _autoStart;
  late Box _settingsBox;

  @override
  void initState() {
    super.initState();
    _loadSettings();
  }

  void _loadSettings() {
    _settingsBox = Hive.box('settings');
    // FIX: Read ONLY from Hive — no widget parameter to overwrite it
    _useImperial = _settingsBox.get('useImperial', defaultValue: false) as bool;
    _autoStart = _settingsBox.get('autoStart', defaultValue: false) as bool;
  }

  void _saveAndPop() {
    _settingsBox.put('useImperial', _useImperial);
    _settingsBox.put('autoStart', _autoStart);
    TripState.instance.autoStart = _autoStart;
    // FIX: Return _useImperial so dashboard can update its display unit
    Navigator.pop(context, _useImperial);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0A0A0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF0A0A0F),
        elevation: 0,
        title: const Text(
          'Settings',
          style: TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.w300,
            letterSpacing: 2,
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white70),
          onPressed: _saveAndPop,
        ),
      ),
      body: SafeArea(
        child: ListView(
          padding: const EdgeInsets.all(24),
          children: [
            const _SectionHeader(label: 'UNITS'),
            _SettingsTile(
              title: 'Imperial Units',
              subtitle: 'Display mph and miles instead of km/h and km',
              value: _useImperial,
              onChanged: (v) {
                setState(() => _useImperial = v);
                // Save immediately on toggle — no need to press back
                _settingsBox.put('useImperial', v);
              },
            ),

            const SizedBox(height: 24),
            const _SectionHeader(label: 'TRIP BEHAVIOUR'),
            _SettingsTile(
              title: 'Auto-Start Trip',
              subtitle:
                  'Automatically starts a trip when speed exceeds 10 km/h',
              value: _autoStart,
              onChanged: (v) {
                setState(() => _autoStart = v);
                _settingsBox.put('autoStart', v);
                TripState.instance.autoStart = v;
              },
            ),

            const SizedBox(height: 24),
            const _SectionHeader(label: 'ABOUT'),
            const _InfoTile(label: 'Version', value: '1.0.0'),
            const _InfoTile(label: 'Speed source', value: 'GPS only (no OBD)'),
            const _InfoTile(label: 'Car display', value: 'Android Auto'),
          ],
        ),
      ),
    );
  }
}

class _SectionHeader extends StatelessWidget {
  const _SectionHeader({required this.label});
  final String label;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Text(
        label,
        style: const TextStyle(
          color: Colors.white38,
          fontSize: 11,
          fontWeight: FontWeight.w600,
          letterSpacing: 1.5,
        ),
      ),
    );
  }
}

class _SettingsTile extends StatelessWidget {
  const _SettingsTile({
    required this.title,
    required this.subtitle,
    required this.value,
    required this.onChanged,
  });

  final String title, subtitle;
  final bool value;
  final ValueChanged<bool> onChanged;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: const Color(0xFF12121E),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: Colors.white12),
      ),
      child: SwitchListTile(
        title: Text(
          title,
          style: const TextStyle(color: Colors.white, fontSize: 15),
        ),
        subtitle: Text(
          subtitle,
          style: const TextStyle(color: Colors.white38, fontSize: 12),
        ),
        value: value,
        onChanged: onChanged,
        activeColor: const Color(0xFF00E676),
        inactiveTrackColor: Colors.white12,
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      ),
    );
  }
}

class _InfoTile extends StatelessWidget {
  const _InfoTile({required this.label, required this.value});
  final String label, value;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      decoration: BoxDecoration(
        color: const Color(0xFF12121E),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: Colors.white12),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: const TextStyle(color: Colors.white70, fontSize: 14),
          ),
          Text(
            value,
            style: const TextStyle(color: Colors.white38, fontSize: 14),
          ),
        ],
      ),
    );
  }
}

------------------------------------

lib/ui/trip_screen.dart

import 'package:flutter/material.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:intl/intl.dart';
import '../models/trip_data.dart';

/// Displays the summary of a just-completed trip.
class TripScreen extends StatelessWidget {
  const TripScreen({super.key, required this.trip});
  final TripData trip;

  @override
  Widget build(BuildContext context) {
    // FIX: Read imperial setting from Hive — same source of truth as dashboard.
    // Old code hardcoded 'km' for the big number and 'mi' for the stat card,
    // showing both units at the same time (1.23 km + 0.76 mi = confusing).
    final box = Hive.box('settings');
    final useImperial = box.get('useImperial', defaultValue: false) as bool;

    final distanceValue =
        useImperial
            ? trip.totalDistanceMiles.toStringAsFixed(2)
            : trip.totalDistanceKm.toStringAsFixed(2);
    final distanceUnit = useImperial ? 'mi' : 'km';

    final avgSpeed =
        useImperial
            ? '${(trip.averageSpeedKmh * 0.621371).toStringAsFixed(1)} mph'
            : '${trip.averageSpeedKmh.toStringAsFixed(1)} km/h';

    final maxSpeed =
        useImperial
            ? '${(trip.maxSpeedKmh * 0.621371).toStringAsFixed(1)} mph'
            : '${trip.maxSpeedKmh.toStringAsFixed(1)} km/h';

    final distanceStat =
        useImperial
            ? '${trip.totalDistanceMiles.toStringAsFixed(2)} mi'
            : '${trip.totalDistanceKm.toStringAsFixed(2)} km';

    return Scaffold(
      backgroundColor: const Color(0xFF0A0A0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF0A0A0F),
        elevation: 0,
        title: const Text(
          'Trip Summary',
          style: TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.w300,
            letterSpacing: 2,
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.close, color: Colors.white70),
          onPressed: () => Navigator.pop(context),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Date and time range
              Text(
                DateFormat('EEEE, d MMMM yyyy').format(trip.startTime),
                style: const TextStyle(
                  color: Colors.white38,
                  fontSize: 13,
                  letterSpacing: 1,
                ),
              ),
              Text(
                '${DateFormat('HH:mm').format(trip.startTime)} — '
                '${trip.endTime != null ? DateFormat('HH:mm').format(trip.endTime!) : '--:--'}',
                style: const TextStyle(color: Colors.white70, fontSize: 15),
              ),

              const SizedBox(height: 40),

              // Big distance — now uses correct unit
              Center(
                child: Column(
                  children: [
                    Text(
                      distanceValue,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 72,
                        fontWeight: FontWeight.w200,
                        letterSpacing: -2,
                      ),
                    ),
                    Text(
                      distanceUnit,
                      style: const TextStyle(
                        color: Colors.white38,
                        fontSize: 16,
                        letterSpacing: 2,
                      ),
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 40),

              // Stats grid — all consistent unit
              Row(
                children: [
                  _SummaryTile(
                    label: 'DURATION',
                    value: trip.formattedDuration,
                    color: const Color(0xFFCE93D8),
                  ),
                  const SizedBox(width: 12),
                  _SummaryTile(
                    label: 'AVG SPEED',
                    value: avgSpeed,
                    color: const Color(0xFF64B5F6),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  _SummaryTile(
                    label: 'MAX SPEED',
                    value: maxSpeed,
                    color: const Color(0xFFEF9A9A),
                  ),
                  const SizedBox(width: 12),
                  _SummaryTile(
                    label: 'DISTANCE',
                    value: distanceStat,
                    color: const Color(0xFFFFB74D),
                  ),
                ],
              ),

              const Spacer(),

              SizedBox(
                width: double.infinity,
                child: OutlinedButton(
                  style: OutlinedButton.styleFrom(
                    side: const BorderSide(color: Colors.white24),
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(14),
                    ),
                  ),
                  onPressed: () => Navigator.pop(context),
                  child: const Text(
                    'DONE',
                    style: TextStyle(color: Colors.white, letterSpacing: 2),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _SummaryTile extends StatelessWidget {
  const _SummaryTile({
    required this.label,
    required this.value,
    required this.color,
  });
  final String label, value;
  final Color color;

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: const Color(0xFF12121E),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: color.withOpacity(0.2)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              label,
              style: TextStyle(
                color: color.withOpacity(0.7),
                fontSize: 10,
                letterSpacing: 1.2,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 6),
            Text(
              value,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 18,
                fontWeight: FontWeight.w300,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Lists all past trips from Hive.
class TripHistoryScreen extends StatelessWidget {
  const TripHistoryScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final tripsBox = Hive.box<TripData>('trips');
    final box = Hive.box('settings');
    final useImperial = box.get('useImperial', defaultValue: false) as bool;

    return Scaffold(
      backgroundColor: const Color(0xFF0A0A0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF0A0A0F),
        elevation: 0,
        title: const Text(
          'Trip History',
          style: TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.w300,
            letterSpacing: 2,
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white70),
          onPressed: () => Navigator.pop(context),
        ),
      ),
      body: ValueListenableBuilder(
        valueListenable: tripsBox.listenable(),
        builder: (context, Box<TripData> box, _) {
          final trips = box.values.toList().reversed.toList();

          if (trips.isEmpty) {
            return const Center(
              child: Text(
                'No trips yet',
                style: TextStyle(color: Colors.white38),
              ),
            );
          }

          return ListView.builder(
            itemCount: trips.length,
            itemBuilder: (context, i) {
              final trip = trips[i];
              final dist =
                  useImperial
                      ? '${trip.totalDistanceMiles.toStringAsFixed(2)} mi'
                      : '${trip.totalDistanceKm.toStringAsFixed(2)} km';
              final avg =
                  useImperial
                      ? '${(trip.averageSpeedKmh * 0.621371).toStringAsFixed(1)} mph'
                      : '${trip.averageSpeedKmh.toStringAsFixed(1)} km/h';

              return Container(
                margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                decoration: BoxDecoration(
                  color: const Color(0xFF12121E),
                  borderRadius: BorderRadius.circular(14),
                  border: Border.all(color: Colors.white12),
                ),
                child: ListTile(
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 8,
                  ),
                  title: Text(
                    dist,
                    style: const TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.w300,
                      fontSize: 18,
                    ),
                  ),
                  subtitle: Text(
                    'Avg $avg  ·  ${trip.formattedDuration}',
                    style: const TextStyle(color: Colors.white38, fontSize: 12),
                  ),
                  trailing: Text(
                    DateFormat(
                      'dd MMM\nHH:mm',
                    ).format(trip.startTime.toLocal()),
                    textAlign: TextAlign.right,
                    style: const TextStyle(color: Colors.white38, fontSize: 12),
                  ),
                  onTap:
                      () => Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (_) => TripScreen(trip: trip),
                        ),
                      ),
                ),
              );
            },
          );
        },
      ),
    );
  }

  String formatDuration(int seconds) {
    final duration = Duration(seconds: seconds);
    if (seconds < 60) return '${seconds}s';
    if (seconds < 3600) {
      return '${duration.inMinutes.toString().padLeft(2, '0')}:'
          '${(duration.inSeconds % 60).toString().padLeft(2, '0')}';
    }
    return '${duration.inHours.toString().padLeft(2, '0')}:'
        '${(duration.inMinutes % 60).toString().padLeft(2, '0')}:'
        '${(duration.inSeconds % 60).toString().padLeft(2, '0')}';
  }
}

------------------------------------

lib/ui/widgets/gps_status_bar.dart

import 'package:flutter/material.dart';

class GpsStatusBar extends StatelessWidget {
  const GpsStatusBar({
    super.key,
    required this.isLost,
    required this.isTracking,
  });

  final bool isLost;
  final bool isTracking;

  @override
  Widget build(BuildContext context) {
    if (!isTracking && !isLost) return const SizedBox.shrink();

    final (text, color, icon) = isLost
        ? ('GPS Signal Lost', const Color(0xFFEF5350), Icons.gps_off_rounded)
        : ('GPS Active', const Color(0xFF00E676), Icons.gps_fixed_rounded);

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 16),
      color: color.withOpacity(0.08),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 13, color: color),
          const SizedBox(width: 6),
          Text(
            text,
            style: TextStyle(
              color: color,
              fontSize: 12,
              fontWeight: FontWeight.w500,
              letterSpacing: 0.5,
            ),
          ),
        ],
      ),
    );
  }
}

------------------------------------

lib/ui/widgets/speed_gauge.dart

import 'dart:math' as math;
import 'package:flutter/material.dart';

/// Animated circular speed gauge — the centrepiece of the dashboard.
class SpeedGauge extends StatelessWidget {
  const SpeedGauge({super.key, required this.speedValue, required this.unit});

  final double speedValue;
  final String unit;

  @override
  Widget build(BuildContext context) {
    final displaySpeed = speedValue.clamp(0.0, 999.0);

    return SizedBox(
      width: 260,
      height: 260,
      child: Stack(
        alignment: Alignment.center,
        children: [
          // Outer ring with arc fill
          CustomPaint(
            size: const Size(260, 260),
            painter: _ArcPainter(speedFraction: (displaySpeed / 200).clamp(0, 1)),
          ),
          // Speed number
          Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TweenAnimationBuilder<double>(
                tween: Tween(end: displaySpeed),
                duration: const Duration(milliseconds: 400),
                curve: Curves.easeOut,
                builder: (_, value, __) => Text(
                  value.toStringAsFixed(0),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 80,
                    fontWeight: FontWeight.w200,
                    height: 1.0,
                    letterSpacing: -2,
                  ),
                ),
              ),
              const SizedBox(height: 4),
              Text(
                unit.toUpperCase(),
                style: const TextStyle(
                  color: Colors.white38,
                  fontSize: 13,
                  letterSpacing: 3,
                  fontWeight: FontWeight.w400,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _ArcPainter extends CustomPainter {
  const _ArcPainter({required this.speedFraction});
  final double speedFraction;

  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2 - 8;

    // Track arc
    final trackPaint = Paint()
      ..color = Colors.white10
      ..style = PaintingStyle.stroke
      ..strokeWidth = 4
      ..strokeCap = StrokeCap.round;

    const startAngle = math.pi * 0.75;
    const sweepAngle = math.pi * 1.5;

    canvas.drawArc(
      Rect.fromCircle(center: center, radius: radius),
      startAngle,
      sweepAngle,
      false,
      trackPaint,
    );

    // Fill arc
    if (speedFraction > 0) {
      final fillColor = _speedColor(speedFraction);
      final fillPaint = Paint()
        ..shader = SweepGradient(
          startAngle: startAngle,
          endAngle: startAngle + sweepAngle * speedFraction,
          colors: [fillColor.withOpacity(0.6), fillColor],
          transform: GradientRotation(startAngle),
        ).createShader(Rect.fromCircle(center: center, radius: radius))
        ..style = PaintingStyle.stroke
        ..strokeWidth = 4
        ..strokeCap = StrokeCap.round;

      canvas.drawArc(
        Rect.fromCircle(center: center, radius: radius),
        startAngle,
        sweepAngle * speedFraction,
        false,
        fillPaint,
      );
    }
  }

  Color _speedColor(double fraction) {
    if (fraction < 0.4) return const Color(0xFF00E676);   // green
    if (fraction < 0.7) return const Color(0xFFFFB74D);   // amber
    return const Color(0xFFEF5350);                        // red
  }

  @override
  bool shouldRepaint(_ArcPainter old) => old.speedFraction != speedFraction;
}

------------------------------------

lib/ui/widgets/stat_card.dart

import 'package:flutter/material.dart';

class StatCard extends StatelessWidget {
  const StatCard({
    super.key,
    required this.label,
    required this.value,
    required this.unit,
    required this.icon,
    required this.color,
    this.isTime = false,
  });

  final String label;
  final String value;
  final String unit;
  final IconData icon;
  final Color color;
  final bool isTime;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      decoration: BoxDecoration(
        color: const Color(0xFF12121E),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, size: 14, color: color.withOpacity(0.8)),
              const SizedBox(width: 6),
              Text(
                label,
                style: TextStyle(
                  color: color.withOpacity(0.7),
                  fontSize: 10,
                  fontWeight: FontWeight.w600,
                  letterSpacing: 1.2,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          isTime
              ? Text(
                  value,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 24,
                    fontWeight: FontWeight.w300,
                    letterSpacing: 1,
                  ),
                )
              : Row(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Text(
                      value,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 24,
                        fontWeight: FontWeight.w300,
                      ),
                    ),
                    if (unit.isNotEmpty) ...[
                      const SizedBox(width: 4),
                      Padding(
                        padding: const EdgeInsets.only(bottom: 3),
                        child: Text(
                          unit,
                          style: TextStyle(
                            color: Colors.white38,
                            fontSize: 11,
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
        ],
      ),
    );
  }
}

------------------------------------

