lib/core/gps_service.dart

import 'dart:async';
import 'package:geolocator/geolocator.dart';
import 'package:carplay/models/location_point.dart';

/// Wraps geolocator with automotive-grade settings.
/// Emits [LocationPoint] fixes every ~1 second.
/// Handles permission checks, GPS loss, and background wakeup.
class GpsService {
  GpsService._();
  static final GpsService instance = GpsService._();

  StreamSubscription<Position>? _subscription;
  final StreamController<LocationPoint> _controller =
      StreamController<LocationPoint>.broadcast();

  Stream<LocationPoint> get locationStream => _controller.stream;
  bool get isTracking => _subscription != null;

  // High-accuracy navigation settings
  static const LocationSettings _locationSettings = LocationSettings(
    accuracy: LocationAccuracy.bestForNavigation,
    distanceFilter: 0, // receive every update, we filter ourselves
    timeLimit: null,
  );

  // ─── Public API ───────────────────────────────────────────────────────────

  Future<void> start() async {
    if (_subscription != null) return;

    // Validate service & permission before streaming
    final serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      _controller.addError(const LocationServiceDisabledException());
      return;
    }

    final permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied ||
        permission == LocationPermission.deniedForever) {
      _controller.addError(
        Exception('Location permission not granted: $permission'),
      );
      return;
    }

    _subscription = Geolocator.getPositionStream(
      locationSettings: _locationSettings,
    ).listen(
      (position) => _controller.add(_fromPosition(position)),
      onError: (Object e) {
        // Emit error downstream but keep subscription alive —
        // GPS often recovers in tunnels / underground parking.
        _controller.addError(e);
      },
      cancelOnError: false,
    );
  }

  Future<void> stop() async {
    await _subscription?.cancel();
    _subscription = null;
  }

  Future<LocationPoint?> currentPosition() async {
    try {
      final p = await Geolocator.getCurrentPosition(
        desiredAccuracy: LocationAccuracy.bestForNavigation,
        timeLimit: const Duration(seconds: 10),
      );
      return _fromPosition(p);
    } catch (_) {
      return null;
    }
  }

  void dispose() {
    stop();
    _controller.close();
  }

  // ─── Private ──────────────────────────────────────────────────────────────

  LocationPoint _fromPosition(Position p) {
    return LocationPoint(
      latitude: p.latitude,
      longitude: p.longitude,
      speedMs: p.speed,
      accuracy: p.accuracy,
      timestamp: p.timestamp,
      altitude: p.altitude,
    );
  }
}

------------------------------------

lib/core/speed_calculator.dart

import 'dart:math' as math;
import 'package:carplay/models/location_point.dart';

/// Pure calculation engine — no Flutter or platform dependencies.
class SpeedCalculator {
  SpeedCalculator._();

  static const double _earthRadiusMeters = 6371000.0;

  // ─── Haversine ────────────────────────────────────────────────────────────

  /// Returns distance in metres between two GPS coordinates.
  static double haversineDistance(LocationPoint a, LocationPoint b) {
    final lat1 = _toRad(a.latitude);
    final lat2 = _toRad(b.latitude);
    final dLat = _toRad(b.latitude - a.latitude);
    final dLon = _toRad(b.longitude - a.longitude);
    final sinDLat = math.sin(dLat / 2);
    final sinDLon = math.sin(dLon / 2);
    final h =
        sinDLat * sinDLat + math.cos(lat1) * math.cos(lat2) * sinDLon * sinDLon;
    return 2 * _earthRadiusMeters * math.asin(math.sqrt(h));
  }

  // ─── Speed ────────────────────────────────────────────────────────────────

  /// Prefer GPS chipset speed; fall back to haversine-derived speed.
  // static double computeCurrentSpeedKmh(
  //   LocationPoint point, {
  //   LocationPoint? previous,
  // }) {
  //   if (point.hasValidSpeed && point.isAccurate) {
  //     return point.speedKmh;
  //   }
  //   if (previous != null) {
  //     final distM = haversineDistance(previous, point);
  //     final dtSec =
  //         point.timestamp
  //             .difference(previous.timestamp)
  //             .inMilliseconds
  //             .toDouble() /
  //         1000.0;
  //     if (dtSec > 0.1 && dtSec < 10.0) {
  //       return (distM / dtSec) * 3.6;
  //     }
  //   }
  //   return 0.0;
  // }

  static double computeCurrentSpeedKmh(
    LocationPoint point, {
    LocationPoint? previous,
  }) {
    if (previous == null) return 0;

    final distM = haversineDistance(previous, point);
    final dtSec =
        point.timestamp.difference(previous.timestamp).inMilliseconds / 1000.0;

    if (dtSec <= 0) return 0;

    return (distM / dtSec) * 3.6;
  }

  /// averageSpeed = totalDistance / movingTime
  static double computeAverageSpeedKmh(
    double totalDistanceMeters,
    int movingTimeSeconds,
  ) {
    if (movingTimeSeconds <= 0) return 0.0;
    return (totalDistanceMeters / movingTimeSeconds) * 3.6;
  }

  // ─── Unit conversion ──────────────────────────────────────────────────────

  static double kmhToMph(double kmh) => kmh * 0.621371;
  static double metersToMiles(double m) => m / 1609.344;
  static double metersToKm(double m) => m / 1000.0;

  // ─── Noise filter ─────────────────────────────────────────────────────────

  /// Returns true when the fix should be accepted for distance accumulation.
  static bool shouldAcceptFix(LocationPoint fix, {LocationPoint? previous}) {
    if (!fix.isAccurate) return false;
    if (previous == null) return true;
    final distM = haversineDistance(previous, fix);
    final dtSec =
        fix.timestamp.difference(previous.timestamp).inMilliseconds / 1000.0;
    if (dtSec <= 0) return false;
    // Reject GPS glitches (> 300 km/h implied)
    final impliedSpeedKmh = (distM / dtSec) * 3.6;
    if (impliedSpeedKmh > 300) return false;
    return true;
  }

  static double _toRad(double deg) => deg * math.pi / 180.0;
}

------------------------------------

lib/core/trip_manager.dart

import 'dart:async';
import 'package:flutter/foundation.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:carplay/models/location_point.dart';
import 'package:carplay/models/trip_data.dart';
import 'package:carplay/core/speed_calculator.dart';
import 'package:carplay/core/gps_service.dart';

/// Live state broadcast during an active trip.
class TripState with ChangeNotifier {
  TripState._();
  static final TripState instance = TripState._();

  // ─── Live fields ──────────────────────────────────────────────────────────

  TripStatus status = TripStatus.idle;
  double currentSpeedKmh = 0;
  double averageSpeedKmh = 0;
  double totalDistanceMeters = 0;
  double maxSpeedKmh = 0;
  int movingTimeSeconds = 0;
  DateTime? tripStartTime;
  DateTime? pauseStartTime;
  LocationPoint? lastPoint;
  bool gpsSignalLost = false;

  // Settings injected externally
  bool autoStart = false;

  // ─── Internal ─────────────────────────────────────────────────────────────

  StreamSubscription<LocationPoint>? _gpsSub;
  Timer? _clockTimer;
  int _pausedSeconds = 0;

  // ─── Computed ─────────────────────────────────────────────────────────────

  int get elapsedSeconds {
    if (tripStartTime == null) return 0;
    final raw = DateTime.now().difference(tripStartTime!).inSeconds;
    return raw - _pausedSeconds;
  }

  String get formattedElapsed {
    final s = elapsedSeconds;
    final h = s ~/ 3600;
    final m = (s % 3600) ~/ 60;
    final sec = s % 60;
    if (h > 0) return '${h}h ${m.toString().padLeft(2, '0')}m';
    return '${m.toString().padLeft(2, '0')}:${sec.toString().padLeft(2, '0')}';
  }

  double get distanceKm => totalDistanceMeters / 1000.0;
  double get distanceMiles => totalDistanceMeters / 1609.344;

  // ─── Public control ───────────────────────────────────────────────────────

  Future<void> startTrip() async {
    if (status == TripStatus.driving) return;
    _reset();
    status = TripStatus.driving;
    tripStartTime = DateTime.now();
    await GpsService.instance.start();
    _gpsSub = GpsService.instance.locationStream.listen(
      _onGpsFix,
      onError: _onGpsError,
    );
    _clockTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      if (status == TripStatus.driving) {
        movingTimeSeconds++;
        notifyListeners();
      }
    });
    notifyListeners();
  }

  void pauseTrip() {
    if (status != TripStatus.driving) return;
    status = TripStatus.paused;
    pauseStartTime = DateTime.now();
    notifyListeners();
  }

  void resumeTrip() {
    if (status != TripStatus.paused) return;
    if (pauseStartTime != null) {
      _pausedSeconds += DateTime.now().difference(pauseStartTime!).inSeconds;
    }
    pauseStartTime = null;
    status = TripStatus.driving;
    notifyListeners();
  }

  Future<TripData?> stopTrip() async {
    if (status == TripStatus.idle) return null;
    status = TripStatus.stopped;
    _clockTimer?.cancel();
    await _gpsSub?.cancel();
    await GpsService.instance.stop();

    final trip = TripData(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      startTime: tripStartTime ?? DateTime.now(),
      endTime: DateTime.now(),
      totalDistanceMeters: totalDistanceMeters,
      averageSpeedKmh: averageSpeedKmh,
      maxSpeedKmh: maxSpeedKmh,
      durationSeconds: elapsedSeconds,
      stateIndex: 'stopped',
    );

    // Persist
    final box = Hive.box<TripData>('trips');
    await box.add(trip);
    _reset();
    notifyListeners();
    return trip;
  }

  // ─── GPS processing ───────────────────────────────────────────────────────

  void _onGpsFix(LocationPoint fix) {
    gpsSignalLost = false;

    final speedKmh = SpeedCalculator.computeCurrentSpeedKmh(
      fix,
      previous: lastPoint,
    );
    currentSpeedKmh = speedKmh;
    if (speedKmh > maxSpeedKmh) maxSpeedKmh = speedKmh;

    // Auto-start
    if (status == TripStatus.idle && autoStart && speedKmh > 10.0) {
      startTrip();
      return;
    }

    // Auto-pause when stationary for > 30 s
    if (status == TripStatus.driving && speedKmh < 2.0) {
      // handled by timer; just record speed
    }

    // Accumulate distance when driving
    if (status == TripStatus.driving) {
      if (lastPoint != null &&
          SpeedCalculator.shouldAcceptFix(fix, previous: lastPoint)) {
        final d = SpeedCalculator.haversineDistance(lastPoint!, fix);
        if (d > 3) {
          totalDistanceMeters += d;
        }
      }

      averageSpeedKmh = SpeedCalculator.computeAverageSpeedKmh(
        totalDistanceMeters,
        movingTimeSeconds,
      );
    }

    lastPoint = fix;
    notifyListeners();
  }

  void _onGpsError(Object error) {
    gpsSignalLost = true;
    notifyListeners();
  }

  // ─── Private ──────────────────────────────────────────────────────────────

  void _reset() {
    currentSpeedKmh = 0;
    averageSpeedKmh = 0;
    totalDistanceMeters = 0;
    maxSpeedKmh = 0;
    movingTimeSeconds = 0;
    _pausedSeconds = 0;
    tripStartTime = null;
    pauseStartTime = null;
    lastPoint = null;
    gpsSignalLost = false;
  }
}

enum TripStatus { idle, driving, paused, stopped }

------------------------------------

lib/main.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:provider/provider.dart';

import 'package:carplay/core/trip_manager.dart';
import 'package:carplay/models/location_point.dart';
import 'package:carplay/models/trip_data.dart';
import 'package:carplay/services/background_service.dart';
import 'package:carplay/ui/dashboard_screen.dart';

Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // ── Hive setup ────────────────────────────────────────────────────────────
  await Hive.initFlutter();
  Hive.registerAdapter(LocationPointAdapter());
  Hive.registerAdapter(TripDataAdapter());
  await Hive.openBox<TripData>('trips');
  await Hive.openBox('settings');

  // ── Background service ───────────────────────────────────────────────────
  await BackgroundServiceManager.initialize();

  // ── System UI ────────────────────────────────────────────────────────────
  SystemChrome.setSystemUIOverlayStyle(
    const SystemUiOverlayStyle(
      statusBarColor: Colors.transparent,
      statusBarIconBrightness: Brightness.light,
    ),
  );

  runApp(
    ChangeNotifierProvider.value(
      value: TripState.instance,
      child: const CarPlayApp(),
    ),
  );
}

class CarPlayApp extends StatelessWidget {
  const CarPlayApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'CarPlay',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        brightness: Brightness.dark,
        scaffoldBackgroundColor: const Color(0xFF0A0A0F),
        colorScheme: const ColorScheme.dark(
          primary: Color(0xFF00E676),
          surface: Color(0xFF12121E),
        ),
        fontFamily: 'SF Pro Display', // falls back to system sans-serif
        useMaterial3: true,
      ),
      home: const DashboardScreen(),
    );
  }
}

------------------------------------

lib/models/location_point.dart

import 'package:hive/hive.dart';

part 'package:carplay/models/location_point.g.dart';

/// A single GPS fix captured during a trip.
/// speedMs comes directly from the GPS chipset via geolocator.
@HiveType(typeId: 0)
class LocationPoint extends HiveObject {
  @HiveField(0)
  final double latitude;

  @HiveField(1)
  final double longitude;

  @HiveField(2)
  final double speedMs; // m/s as reported by GPS hardware

  @HiveField(3)
  final double accuracy; // horizontal accuracy in metres

  @HiveField(4)
  final DateTime timestamp;

  @HiveField(5)
  final double altitude;

  LocationPoint({
    required this.latitude,
    required this.longitude,
    required this.speedMs,
    required this.accuracy,
    required this.timestamp,
    this.altitude = 0.0,
  });

  double get speedKmh => speedMs >= 0 ? speedMs * 3.6 : 0.0;
  double get speedMph => speedMs >= 0 ? speedMs * 2.23694 : 0.0;

  bool get hasValidSpeed => speedMs >= 0;
  bool get isAccurate => accuracy <= 10.0;

  @override
  String toString() =>
      'LocationPoint(${speedKmh.toStringAsFixed(1)} km/h, acc ${accuracy.toStringAsFixed(0)} m)';
}

------------------------------------

lib/models/location_point.g.dart

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'location_point.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class LocationPointAdapter extends TypeAdapter<LocationPoint> {
  @override
  final int typeId = 0;

  @override
  LocationPoint read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return LocationPoint(
      latitude: fields[0] as double,
      longitude: fields[1] as double,
      speedMs: fields[2] as double,
      accuracy: fields[3] as double,
      timestamp: fields[4] as DateTime,
      altitude: fields[5] as double,
    );
  }

  @override
  void write(BinaryWriter writer, LocationPoint obj) {
    writer
      ..writeByte(6)
      ..writeByte(0)
      ..write(obj.latitude)
      ..writeByte(1)
      ..write(obj.longitude)
      ..writeByte(2)
      ..write(obj.speedMs)
      ..writeByte(3)
      ..write(obj.accuracy)
      ..writeByte(4)
      ..write(obj.timestamp)
      ..writeByte(5)
      ..write(obj.altitude);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LocationPointAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

------------------------------------

lib/models/trip_data.dart

import 'package:hive/hive.dart';

part 'package:carplay/models/trip_data.g.dart';

enum TripStatus { idle, driving, paused, stopped }

/// Immutable summary stored after each trip completes.
@HiveType(typeId: 1)
class TripData extends HiveObject {
  @HiveField(0)
  final String id;

  @HiveField(1)
  final DateTime startTime;

  @HiveField(2)
  final DateTime? endTime;

  @HiveField(3)
  final double totalDistanceMeters;

  @HiveField(4)
  final double averageSpeedKmh;

  @HiveField(5)
  final double maxSpeedKmh;

  @HiveField(6)
  final int durationSeconds;

  @HiveField(7)
  final String stateIndex; // stored as string for portability

  TripData({
    required this.id,
    required this.startTime,
    this.endTime,
    required this.totalDistanceMeters,
    required this.averageSpeedKmh,
    required this.maxSpeedKmh,
    required this.durationSeconds,
    required this.stateIndex,
  });

  double get totalDistanceKm => totalDistanceMeters / 1000.0;
  double get totalDistanceMiles => totalDistanceMeters / 1609.344;

  String get formattedDuration {
    final h = durationSeconds ~/ 3600;
    final m = (durationSeconds % 3600) ~/ 60;
    final s = durationSeconds % 60;
    if (h > 0) return '${h}h ${m.toString().padLeft(2, '0')}m';
    return '${m}m ${s.toString().padLeft(2, '0')}s';
  }

  TripData copyWith({
    DateTime? endTime,
    double? totalDistanceMeters,
    double? averageSpeedKmh,
    double? maxSpeedKmh,
    int? durationSeconds,
    String? stateIndex,
  }) {
    return TripData(
      id: id,
      startTime: startTime,
      endTime: endTime ?? this.endTime,
      totalDistanceMeters: totalDistanceMeters ?? this.totalDistanceMeters,
      averageSpeedKmh: averageSpeedKmh ?? this.averageSpeedKmh,
      maxSpeedKmh: maxSpeedKmh ?? this.maxSpeedKmh,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      stateIndex: stateIndex ?? this.stateIndex,
    );
  }
}

------------------------------------

lib/models/trip_data.g.dart

// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'trip_data.dart';

// **************************************************************************
// TypeAdapterGenerator
// **************************************************************************

class TripDataAdapter extends TypeAdapter<TripData> {
  @override
  final int typeId = 1;

  @override
  TripData read(BinaryReader reader) {
    final numOfFields = reader.readByte();
    final fields = <int, dynamic>{
      for (int i = 0; i < numOfFields; i++) reader.readByte(): reader.read(),
    };
    return TripData(
      id: fields[0] as String,
      startTime: fields[1] as DateTime,
      endTime: fields[2] as DateTime?,
      totalDistanceMeters: fields[3] as double,
      averageSpeedKmh: fields[4] as double,
      maxSpeedKmh: fields[5] as double,
      durationSeconds: fields[6] as int,
      stateIndex: fields[7] as String,
    );
  }

  @override
  void write(BinaryWriter writer, TripData obj) {
    writer
      ..writeByte(8)
      ..writeByte(0)
      ..write(obj.id)
      ..writeByte(1)
      ..write(obj.startTime)
      ..writeByte(2)
      ..write(obj.endTime)
      ..writeByte(3)
      ..write(obj.totalDistanceMeters)
      ..writeByte(4)
      ..write(obj.averageSpeedKmh)
      ..writeByte(5)
      ..write(obj.maxSpeedKmh)
      ..writeByte(6)
      ..write(obj.durationSeconds)
      ..writeByte(7)
      ..write(obj.stateIndex);
  }

  @override
  int get hashCode => typeId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TripDataAdapter &&
          runtimeType == other.runtimeType &&
          typeId == other.typeId;
}

------------------------------------

lib/platform_bridge/car_data_sender.dart

import 'package:flutter/services.dart';

/// One-way bridge: Flutter → Native car display.
///
/// The native side (Android Auto / CarPlay) registers a MethodChannel handler
/// that receives speed data and refreshes the car UI template.
///
/// Channel name must match exactly in Kotlin and Swift.
class CarDataSender {
  CarDataSender._();
  static final CarDataSender instance = CarDataSender._();

  static const MethodChannel _channel = MethodChannel(
    'com.example.carplay/car_display',
  );

  // Received from background service or TripState
  Future<void> sendUpdate({
    required double currentSpeedKmh,
    required double averageSpeedKmh,
    required double totalDistanceMeters,
    required int movingTimeSeconds,
    required String tripStatus, // "idle" | "driving" | "paused" | "stopped"
    bool useImperial = false,
  }) async {
    try {
      await _channel.invokeMethod('updateDisplay', {
        'currentSpeedKmh': currentSpeedKmh,
        'averageSpeedKmh': averageSpeedKmh,
        'totalDistanceMeters': totalDistanceMeters,
        'movingTimeSeconds': movingTimeSeconds,
        'tripStatus': tripStatus,
        'useImperial': useImperial,
        // Pre-converted values the native layer can display directly
        'currentSpeedDisplay':
            useImperial
                ? (currentSpeedKmh * 0.621371).toStringAsFixed(0)
                : currentSpeedKmh.toStringAsFixed(0),
        'averageSpeedDisplay':
            useImperial
                ? (averageSpeedKmh * 0.621371).toStringAsFixed(0)
                : averageSpeedKmh.toStringAsFixed(0),
        'speedUnit': useImperial ? 'mph' : 'km/h',
        'distanceDisplay':
            useImperial
                ? '${(totalDistanceMeters / 1609.344).toStringAsFixed(2)} mi'
                : '${(totalDistanceMeters / 1000).toStringAsFixed(2)} km',
        'durationDisplay': _formatDuration(movingTimeSeconds),
      });
    } on PlatformException catch (e) {
      // Car display not connected — safe to ignore
      debugPrint('CarDataSender: PlatformException ${e.message}');
    } on MissingPluginException {
      // Running on simulator without native car library — safe to ignore
    }
  }

  static String _formatDuration(int seconds) {
    final h = seconds ~/ 3600;
    final m = (seconds % 3600) ~/ 60;
    final s = seconds % 60;
    if (h > 0) return '${h}h ${m.toString().padLeft(2, '0')}m';
    return '${m.toString().padLeft(2, '0')}:${s.toString().padLeft(2, '0')}';
  }
}

// ignore: avoid_print
void debugPrint(String msg) => print('[Average] $msg');

------------------------------------

lib/services/background_service.dart

import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:carplay/core/gps_service.dart';
import 'package:carplay/core/speed_calculator.dart';
import 'package:carplay/core/trip_manager.dart';
import 'package:carplay/models/location_point.dart';
import 'package:carplay/models/trip_data.dart';

/// Bootstraps flutter_background_service so tracking persists when the
/// phone screen turns off or the user switches apps.
///
/// Architecture:
///   Main isolate  ←→  Background isolate (this file)
///   The background isolate owns the GPS stream and TripState.
///   It broadcasts updates to the main isolate via ServiceInstance events.
class BackgroundServiceManager {
  static const String _channelId = 'com.example.carplay.tracking';
  static const String _channelName = 'CarPlay – Speed Tracking';

  static Future<void> initialize() async {
    final service = FlutterBackgroundService();

    await service.configure(
      // ── Android: foreground service with persistent notification ──────────
      androidConfiguration: AndroidConfiguration(
        onStart: _onStart,
        isForegroundMode: true,
        autoStart: false,
        notificationChannelId: _channelId,
        initialNotificationTitle: 'CarPlay',
        initialNotificationContent: 'Speed tracking active',
        foregroundServiceNotificationId: 888,
        foregroundServiceTypes: [AndroidForegroundType.location],
      ),
      // ── iOS: background fetch + location ─────────────────────────────────
      iosConfiguration: IosConfiguration(
        onForeground: _onStart,
        onBackground: _onIosBackground,
        autoStart: false,
      ),
    );
  }

  static Future<bool> start() => FlutterBackgroundService().startService();
  static Future<bool> isRunning() => FlutterBackgroundService().isRunning();

  static void stop() => FlutterBackgroundService().invoke('stopService');

  /// Send a command to the background isolate.
  static void send(String event, [Map<String, dynamic>? data]) =>
      FlutterBackgroundService().invoke(event, data);

  // ─── Background isolate entry point ──────────────────────────────────────

  @pragma('vm:entry-point')
  static Future<void> _onStart(ServiceInstance service) async {
    DartPluginRegistrant.ensureInitialized();

    // Re-open Hive in the background isolate
    await Hive.initFlutter();
    if (!Hive.isAdapterRegistered(0)) {
      Hive.registerAdapter(LocationPointAdapter());
    }
    if (!Hive.isAdapterRegistered(1)) {
      Hive.registerAdapter(TripDataAdapter());
    }
    await Hive.openBox<TripData>('trips');

    // Local state for this isolate
    double totalDistanceMeters = 0;
    double currentSpeedKmh = 0;
    double averageSpeedKmh = 0;
    int movingTimeSeconds = 0;
    double maxSpeedKmh = 0;
    LocationPoint? lastPoint;
    bool isActive = false;

    // ── Listen for commands from main isolate ─────────────────────────────
    service.on('start').listen((_) async {
      isActive = true;
      totalDistanceMeters = 0;
      currentSpeedKmh = 0;
      averageSpeedKmh = 0;
      movingTimeSeconds = 0;
      maxSpeedKmh = 0;
      lastPoint = null;
      await GpsService.instance.start();
    });

    service.on('stop').listen((_) async {
      isActive = false;
      await GpsService.instance.stop();
      service.invoke('stopped', {});
    });

    service.on('stopService').listen((_) async {
      await GpsService.instance.stop();
      service.stopSelf();
    });

    // ── GPS stream ────────────────────────────────────────────────────────
    Timer? clockTimer;
    clockTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      if (isActive) movingTimeSeconds++;
    });

    GpsService.instance.locationStream.listen((fix) {
      if (!isActive) return;

      currentSpeedKmh = SpeedCalculator.computeCurrentSpeedKmh(
        fix,
        previous: lastPoint,
      );
      if (currentSpeedKmh > maxSpeedKmh) maxSpeedKmh = currentSpeedKmh;

      if (lastPoint != null &&
          SpeedCalculator.shouldAcceptFix(fix, previous: lastPoint)) {
        totalDistanceMeters += SpeedCalculator.haversineDistance(
          lastPoint!,
          fix,
        );
      }

      averageSpeedKmh = SpeedCalculator.computeAverageSpeedKmh(
        totalDistanceMeters,
        movingTimeSeconds,
      );

      lastPoint = fix;

      // Broadcast to main isolate & car displays
      service.invoke('update', {
        'currentSpeedKmh': currentSpeedKmh,
        'averageSpeedKmh': averageSpeedKmh,
        'totalDistanceMeters': totalDistanceMeters,
        'movingTimeSeconds': movingTimeSeconds,
        'maxSpeedKmh': maxSpeedKmh,
        'lat': fix.latitude,
        'lng': fix.longitude,
        'accuracy': fix.accuracy,
      });

      // Update foreground notification
      if (service is AndroidServiceInstance) {
        service.setForegroundNotificationInfo(
          title: 'Average – ${currentSpeedKmh.toStringAsFixed(0)} km/h',
          content:
              'Avg ${averageSpeedKmh.toStringAsFixed(0)} km/h · ${(totalDistanceMeters / 1000).toStringAsFixed(2)} km',
        );
      }
    });
  }

  @pragma('vm:entry-point')
  static Future<bool> _onIosBackground(ServiceInstance service) async {
    WidgetsFlutterBinding.ensureInitialized();
    DartPluginRegistrant.ensureInitialized();
    return true;
  }
}

------------------------------------

lib/services/permission_service.dart

import 'package:permission_handler/permission_handler.dart';

/// Handles all runtime permission requests for the app.
class PermissionService {
  PermissionService._();
  static final PermissionService instance = PermissionService._();

  /// Returns true only when ALL required permissions are granted.
  Future<bool> requestAll() async {
    // Always-while-driving requires background location
    final results = await [
      Permission.location,
      Permission.locationAlways,
      Permission.notification, // required for foreground service on Android 13+
    ].request();

    final locationOk = results[Permission.location] == PermissionStatus.granted;
    final bgOk = results[Permission.locationAlways] == PermissionStatus.granted;

    return locationOk && bgOk;
  }

  Future<bool> hasLocationPermission() async {
    final status = await Permission.location.status;
    return status == PermissionStatus.granted;
  }

  Future<bool> hasBackgroundLocationPermission() async {
    final status = await Permission.locationAlways.status;
    return status == PermissionStatus.granted;
  }

  Future<bool> isLocationServiceEnabled() async {
    return Permission.location.serviceStatus.then(
      (s) => s == ServiceStatus.enabled,
    );
  }

  Future<void> openSettings() => openAppSettings();
}

------------------------------------

lib/ui/dashboard_screen.dart

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import 'package:carplay/core/trip_manager.dart';
import 'package:carplay/platform_bridge/car_data_sender.dart';
import 'package:carplay/services/permission_service.dart';
import 'package:carplay/ui/settings_screen.dart';
import 'package:carplay/ui/trip_screen.dart';
import 'package:carplay/ui/widgets/speed_gauge.dart';
import 'package:carplay/ui/widgets/stat_card.dart';
import 'package:carplay/ui/widgets/gps_status_bar.dart';

class DashboardScreen extends StatefulWidget {
  const DashboardScreen({super.key});

  @override
  State<DashboardScreen> createState() => _DashboardScreenState();
}

class _DashboardScreenState extends State<DashboardScreen>
    with WidgetsBindingObserver {
  bool _useImperial = false;

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    // Lock to portrait while in phone UI; car display handles landscape
    SystemChrome.setPreferredOrientations([
      DeviceOrientation.portraitUp,
      DeviceOrientation.landscapeLeft,
      DeviceOrientation.landscapeRight,
    ]);
    _checkPermissions();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    WakelockPlus.disable();
    super.dispose();
  }

  Future<void> _checkPermissions() async {
    final ok = await PermissionService.instance.hasLocationPermission();
    if (!ok && mounted) {
      _showPermissionDialog();
    }
  }

  void _showPermissionDialog() {
    showDialog(
      context: context,
      barrierDismissible: false,
      builder:
          (_) => AlertDialog(
            title: const Text('Location Required'),
            content: const Text(
              'Carplay needs precise location access (including background) '
              'to track your speed while driving.',
            ),
            actions: [
              TextButton(
                onPressed: () async {
                  Navigator.pop(context);
                  final granted = await PermissionService.instance.requestAll();
                  if (!granted && mounted) {
                    PermissionService.instance.openSettings();
                  }
                },
                child: const Text('Grant Access'),
              ),
            ],
          ),
    );
  }

  Future<void> _toggleTrip(TripState trip) async {
    if (trip.status == TripStatus.idle || trip.status == TripStatus.stopped) {
      final ok = await PermissionService.instance.hasLocationPermission();
      if (!ok) {
        _showPermissionDialog();
        return;
      }
      await WakelockPlus.enable();
      await trip.startTrip();
    } else if (trip.status == TripStatus.driving) {
      final finished = await trip.stopTrip();
      await WakelockPlus.disable();
      if (finished != null && mounted) {
        Navigator.push(
          context,
          MaterialPageRoute(builder: (_) => TripScreen(trip: finished)),
        );
      }
    } else if (trip.status == TripStatus.paused) {
      trip.resumeTrip();
    }
  }

  void _pauseTrip(TripState trip) {
    if (trip.status == TripStatus.driving) {
      trip.pauseTrip();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<TripState>(
      builder: (context, trip, _) {
        // Send data to car display every rebuild (throttled by GPS ~1 Hz)
        CarDataSender.instance.sendUpdate(
          currentSpeedKmh: trip.currentSpeedKmh,
          averageSpeedKmh: trip.averageSpeedKmh,
          totalDistanceMeters: trip.totalDistanceMeters,
          movingTimeSeconds: trip.movingTimeSeconds,
          tripStatus: trip.status.name,
          useImperial: _useImperial,
        );

        return Scaffold(
          backgroundColor: const Color(0xFF0A0A0F),
          appBar: _buildAppBar(context, trip),
          body: SafeArea(
            child: Column(
              children: [
                GpsStatusBar(
                  isLost: trip.gpsSignalLost,
                  isTracking: trip.status == TripStatus.driving,
                ),
                Expanded(child: _buildBody(context, trip)),
                _buildControls(context, trip),
                const SizedBox(height: 24),
              ],
            ),
          ),
        );
      },
    );
  }

  PreferredSizeWidget _buildAppBar(BuildContext context, TripState trip) {
    return AppBar(
      backgroundColor: const Color(0xFF0A0A0F),
      elevation: 0,
      title: Row(
        children: [
          const Text(
            'CarPlay',
            style: TextStyle(
              color: Colors.white,
              fontSize: 20,
              fontWeight: FontWeight.w300,
              letterSpacing: 3,
            ),
          ),
          const SizedBox(width: 8),
          if (trip.status == TripStatus.driving)
            Container(
              width: 8,
              height: 8,
              decoration: const BoxDecoration(
                color: Color(0xFF00E676),
                shape: BoxShape.circle,
              ),
            ),
        ],
      ),
      actions: [
        IconButton(
          icon: const Icon(Icons.history_rounded, color: Colors.white54),
          onPressed:
              () => Navigator.push(
                context,
                MaterialPageRoute(builder: (_) => const TripHistoryScreen()),
              ),
        ),
        IconButton(
          icon: const Icon(Icons.settings_outlined, color: Colors.white54),
          onPressed: () async {
            final result = await Navigator.push(
              context,
              MaterialPageRoute(
                builder: (_) => SettingsScreen(initialImperial: _useImperial),
              ),
            );
            if (result is bool) setState(() => _useImperial = result);
          },
        ),
      ],
    );
  }

  Widget _buildBody(BuildContext context, TripState trip) {
    final speed =
        _useImperial ? (trip.currentSpeedKmh * 0.621371) : trip.currentSpeedKmh;
    final unit = _useImperial ? 'mph' : 'km/h';

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 24),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // ── Primary speed gauge ──────────────────────────────────────────
          SpeedGauge(speedValue: speed, unit: unit),

          const SizedBox(height: 48),

          // ── Stats row ────────────────────────────────────────────────────
          Row(
            children: [
              Expanded(
                child: StatCard(
                  label: 'AVG SPEED',
                  value:
                      _useImperial
                          ? (trip.averageSpeedKmh * 0.621371).toStringAsFixed(1)
                          : trip.averageSpeedKmh.toStringAsFixed(1),
                  unit: unit,
                  icon: Icons.show_chart_rounded,
                  color: const Color(0xFF64B5F6),
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: StatCard(
                  label: 'DISTANCE',
                  value:
                      _useImperial
                          ? (trip.totalDistanceMeters / 1609.344)
                              .toStringAsFixed(2)
                          : (trip.totalDistanceMeters / 1000).toStringAsFixed(
                            2,
                          ),
                  unit: _useImperial ? 'mi' : 'km',
                  icon: Icons.straighten_rounded,
                  color: const Color(0xFFFFB74D),
                ),
              ),
            ],
          ),

          const SizedBox(height: 12),

          Row(
            children: [
              Expanded(
                child: StatCard(
                  label: 'DURATION',
                  value: trip.formattedElapsed,
                  unit: '',
                  icon: Icons.timer_outlined,
                  color: const Color(0xFFCE93D8),
                  isTime: true,
                ),
              ),
              const SizedBox(width: 12),
              Expanded(
                child: StatCard(
                  label: 'MAX SPEED',
                  value:
                      _useImperial
                          ? (trip.maxSpeedKmh * 0.621371).toStringAsFixed(1)
                          : trip.maxSpeedKmh.toStringAsFixed(1),
                  unit: unit,
                  icon: Icons.speed_rounded,
                  color: const Color(0xFFEF9A9A),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildControls(BuildContext context, TripState trip) {
    final isDriving = trip.status == TripStatus.driving;
    final isPaused = trip.status == TripStatus.paused;
    final isIdle =
        trip.status == TripStatus.idle || trip.status == TripStatus.stopped;

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 24),
      child: Row(
        children: [
          // Pause button (only while driving)
          AnimatedOpacity(
            opacity: isDriving ? 1.0 : 0.0,
            duration: const Duration(milliseconds: 300),
            child: GestureDetector(
              onTap: isDriving ? () => _pauseTrip(trip) : null,
              child: Container(
                width: 56,
                height: 56,
                decoration: BoxDecoration(
                  color: const Color(0xFF1C1C2E),
                  borderRadius: BorderRadius.circular(16),
                  border: Border.all(color: Colors.white12),
                ),
                child: const Icon(
                  Icons.pause_rounded,
                  color: Colors.white70,
                  size: 28,
                ),
              ),
            ),
          ),

          if (isDriving) const SizedBox(width: 12),

          // Main CTA button
          Expanded(
            child: _TripButton(
              status: trip.status,
              onTap: () => _toggleTrip(trip),
            ),
          ),
        ],
      ),
    );
  }
}

// ─── Trip Button ──────────────────────────────────────────────────────────────

class _TripButton extends StatelessWidget {
  const _TripButton({required this.status, required this.onTap});

  final TripStatus status;
  final VoidCallback onTap;

  @override
  Widget build(BuildContext context) {
    final (label, color, icon) = switch (status) {
      TripStatus.idle => (
        'START TRIP',
        const Color(0xFF00E676),
        Icons.play_arrow_rounded,
      ),
      TripStatus.driving => (
        'STOP TRIP',
        const Color(0xFFEF5350),
        Icons.stop_rounded,
      ),
      TripStatus.paused => (
        'RESUME',
        const Color(0xFFFFB74D),
        Icons.play_arrow_rounded,
      ),
      TripStatus.stopped => (
        'NEW TRIP',
        const Color(0xFF00E676),
        Icons.play_arrow_rounded,
      ),
    };

    return GestureDetector(
      onTap: onTap,
      child: Container(
        height: 56,
        decoration: BoxDecoration(
          color: color.withOpacity(0.15),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: color.withOpacity(0.6), width: 1.5),
        ),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(icon, color: color, size: 22),
            const SizedBox(width: 10),
            Text(
              label,
              style: TextStyle(
                color: color,
                fontSize: 15,
                fontWeight: FontWeight.w600,
                letterSpacing: 1.5,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

------------------------------------

lib/ui/settings_screen.dart

import 'package:flutter/material.dart';
import 'package:hive_flutter/hive_flutter.dart';
import '../core/trip_manager.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key, required this.initialImperial});
  final bool initialImperial;

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  late bool _useImperial;
  late bool _autoStart;
  late Box _settingsBox;

  @override
  void initState() {
    super.initState();
    _loadSettings();
  }

  void _loadSettings() {
    _settingsBox = Hive.box('settings');
    _useImperial = _settingsBox.get('useImperial', defaultValue: false) as bool;
    _autoStart = _settingsBox.get('autoStart', defaultValue: false) as bool;
    _useImperial = widget.initialImperial;
  }

  void _saveAndPop() {
    _settingsBox.put('useImperial', _useImperial);
    _settingsBox.put('autoStart', _autoStart);
    TripState.instance.autoStart = _autoStart;
    Navigator.pop(context, _useImperial);
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0A0A0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF0A0A0F),
        elevation: 0,
        title: const Text(
          'Settings',
          style: TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.w300,
            letterSpacing: 2,
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.arrow_back, color: Colors.white70),
          onPressed: _saveAndPop,
        ),
      ),
      body: SafeArea(
        child: ListView(
          padding: const EdgeInsets.all(24),
          children: [
            _SectionHeader(label: 'UNITS'),
            _SettingsTile(
              title: 'Imperial Units',
              subtitle: 'Display mph and miles instead of km/h and km',
              value: _useImperial,
              onChanged: (v) {
                setState(() => _useImperial = v);
                Hive.box('settings').put('useImperial', _useImperial);
              },
            ),

            const SizedBox(height: 24),
            _SectionHeader(label: 'TRIP BEHAVIOUR'),
            _SettingsTile(
              title: 'Auto-Start Trip',
              subtitle:
                  'Automatically starts a trip when speed exceeds 10 km/h',
              value: _autoStart,
              onChanged: (v) {
                setState(() => _autoStart = v);
                Hive.box('settings').put('autoStart', _autoStart);
              },
            ),

            const SizedBox(height: 24),
            _SectionHeader(label: 'ABOUT'),
            _InfoTile(label: 'Version', value: '1.0.0'),
            _InfoTile(label: 'Speed source', value: 'GPS only (no OBD)'),
            _InfoTile(label: 'Car display', value: 'Android Auto & CarPlay'),
          ],
        ),
      ),
    );
  }
}

class _SectionHeader extends StatelessWidget {
  const _SectionHeader({required this.label});
  final String label;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Text(
        label,
        style: const TextStyle(
          color: Colors.white38,
          fontSize: 11,
          fontWeight: FontWeight.w600,
          letterSpacing: 1.5,
        ),
      ),
    );
  }
}

class _SettingsTile extends StatelessWidget {
  const _SettingsTile({
    required this.title,
    required this.subtitle,
    required this.value,
    required this.onChanged,
  });

  final String title, subtitle;
  final bool value;
  final ValueChanged<bool> onChanged;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      decoration: BoxDecoration(
        color: const Color(0xFF12121E),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: Colors.white12),
      ),
      child: SwitchListTile(
        title: Text(
          title,
          style: const TextStyle(color: Colors.white, fontSize: 15),
        ),
        subtitle: Text(
          subtitle,
          style: const TextStyle(color: Colors.white38, fontSize: 12),
        ),
        value: value,
        onChanged: onChanged,
        activeColor: const Color(0xFF00E676),
        inactiveTrackColor: Colors.white12,
        contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      ),
    );
  }
}

class _InfoTile extends StatelessWidget {
  const _InfoTile({required this.label, required this.value});
  final String label, value;

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.only(bottom: 8),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      decoration: BoxDecoration(
        color: const Color(0xFF12121E),
        borderRadius: BorderRadius.circular(14),
        border: Border.all(color: Colors.white12),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            label,
            style: const TextStyle(color: Colors.white70, fontSize: 14),
          ),
          Text(
            value,
            style: const TextStyle(color: Colors.white38, fontSize: 14),
          ),
        ],
      ),
    );
  }
}

------------------------------------

lib/ui/trip_screen.dart

import 'package:flutter/material.dart';
import 'package:hive/hive.dart';
import 'package:hive_flutter/hive_flutter.dart';
import 'package:intl/intl.dart';
import '../models/trip_data.dart';

/// Displays the summary of a just-completed trip.
class TripScreen extends StatelessWidget {
  const TripScreen({super.key, required this.trip});
  final TripData trip;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF0A0A0F),
      appBar: AppBar(
        backgroundColor: const Color(0xFF0A0A0F),
        elevation: 0,
        title: const Text(
          'Trip Summary',
          style: TextStyle(
            color: Colors.white,
            fontWeight: FontWeight.w300,
            letterSpacing: 2,
          ),
        ),
        leading: IconButton(
          icon: const Icon(Icons.close, color: Colors.white70),
          onPressed: () => Navigator.pop(context),
        ),
      ),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Date
              Text(
                DateFormat('EEEE, d MMMM yyyy').format(trip.startTime),
                style: const TextStyle(
                  color: Colors.white38,
                  fontSize: 13,
                  letterSpacing: 1,
                ),
              ),
              Text(
                '${DateFormat('HH:mm').format(trip.startTime)} — ${trip.endTime != null ? DateFormat('HH:mm').format(trip.endTime!) : '--:--'}',
                style: const TextStyle(color: Colors.white70, fontSize: 15),
              ),
              const SizedBox(height: 40),

              // Big distance
              Center(
                child: Column(
                  children: [
                    Text(
                      trip.totalDistanceKm.toStringAsFixed(2),
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 72,
                        fontWeight: FontWeight.w200,
                        letterSpacing: -2,
                      ),
                    ),
                    const Text(
                      'km',
                      style: TextStyle(
                        color: Colors.white38,
                        fontSize: 16,
                        letterSpacing: 2,
                      ),
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 40),

              // Stats grid
              Row(
                children: [
                  _SummaryTile(
                    label: 'DURATION',
                    value: trip.formattedDuration,
                    color: const Color(0xFFCE93D8),
                  ),
                  const SizedBox(width: 12),
                  _SummaryTile(
                    label: 'AVG SPEED',
                    value: '${trip.averageSpeedKmh.toStringAsFixed(1)} km/h',
                    color: const Color(0xFF64B5F6),
                  ),
                ],
              ),
              const SizedBox(height: 12),
              Row(
                children: [
                  _SummaryTile(
                    label: 'MAX SPEED',
                    value: '${trip.maxSpeedKmh.toStringAsFixed(1)} km/h',
                    color: const Color(0xFFEF9A9A),
                  ),
                  const SizedBox(width: 12),
                  _SummaryTile(
                    label: 'DISTANCE',
                    value: '${trip.totalDistanceMiles.toStringAsFixed(2)} mi',
                    color: const Color(0xFFFFB74D),
                  ),
                ],
              ),

              const Spacer(),

              SizedBox(
                width: double.infinity,
                child: OutlinedButton(
                  style: OutlinedButton.styleFrom(
                    side: const BorderSide(color: Colors.white24),
                    padding: const EdgeInsets.symmetric(vertical: 16),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(14),
                    ),
                  ),
                  onPressed: () => Navigator.pop(context),
                  child: const Text(
                    'DONE',
                    style: TextStyle(color: Colors.white, letterSpacing: 2),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class _SummaryTile extends StatelessWidget {
  const _SummaryTile({
    required this.label,
    required this.value,
    required this.color,
  });
  final String label, value;
  final Color color;

  @override
  Widget build(BuildContext context) {
    return Expanded(
      child: Container(
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: const Color(0xFF12121E),
          borderRadius: BorderRadius.circular(14),
          border: Border.all(color: color.withOpacity(0.2)),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              label,
              style: TextStyle(
                color: color.withOpacity(0.7),
                fontSize: 10,
                letterSpacing: 1.2,
                fontWeight: FontWeight.w600,
              ),
            ),
            const SizedBox(height: 6),
            Text(
              value,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 18,
                fontWeight: FontWeight.w300,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Lists all past trips from Hive.
// class TripHistoryScreen extends StatelessWidget {
//   const TripHistoryScreen({super.key});

//   @override
//   Widget build(BuildContext context) {
//     return Scaffold(
//       backgroundColor: const Color(0xFF0A0A0F),
//       appBar: AppBar(
//         backgroundColor: const Color(0xFF0A0A0F),
//         elevation: 0,
//         title: const Text(
//           'Trip History',
//           style: TextStyle(
//             color: Colors.white,
//             fontWeight: FontWeight.w300,
//             letterSpacing: 2,
//           ),
//         ),
//         leading: IconButton(
//           icon: const Icon(Icons.arrow_back, color: Colors.white70),
//           onPressed: () => Navigator.pop(context),
//         ),
//       ),
//       // ValueListenableBuilder responds to Hive changes automatically
//       body: const _TripHistoryBody(),
//     );
//   }
// }

class TripHistoryScreen extends StatelessWidget {
  const TripHistoryScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final tripsBox = Hive.box<TripData>('trips');

    return Scaffold(
      appBar: AppBar(title: const Text("Trip History")),
      body: ValueListenableBuilder(
        valueListenable: tripsBox.listenable(),
        builder: (context, Box<TripData> box, _) {
          final trips = box.values.toList().reversed.toList();

          if (trips.isEmpty) {
            return const Center(child: Text("No trips yet"));
          }

          return ListView.builder(
            itemCount: trips.length,
            itemBuilder: (context, i) {
              final trip = trips[i];

              return ListTile(
                title: Text(
                  "${(trip.totalDistanceMeters / 1000).toStringAsFixed(2)} km",
                ),
                subtitle: Text(
                  "Avg ${trip.averageSpeedKmh.toStringAsFixed(1)} km/h • "
                  "Duration ${formatDuration(trip.durationSeconds)}",
                ),
                trailing: Text(
                  trip.startTime.toLocal().toString().substring(0, 16),
                ),
              );
            },
          );
        },
      ),
    );
  }

  String formatDuration(int seconds) {
    final duration = Duration(seconds: seconds);

    if (seconds < 60) {
      return "${seconds}s";
    }

    if (seconds < 3600) {
      final minutes = duration.inMinutes;
      final secs = duration.inSeconds % 60;
      return "${minutes.toString().padLeft(2, '0')}:"
          "${secs.toString().padLeft(2, '0')}";
    }

    final hours = duration.inHours;
    final minutes = duration.inMinutes % 60;
    final secs = duration.inSeconds % 60;

    return "${hours.toString().padLeft(2, '0')}:"
        "${minutes.toString().padLeft(2, '0')}:"
        "${secs.toString().padLeft(2, '0')}";
  }
}

class _TripHistoryBody extends StatelessWidget {
  const _TripHistoryBody();

  @override
  Widget build(BuildContext context) {
    // In production wire to a Hive ValueListenableBuilder
    return const Center(
      child: Text(
        'Trip history will appear here',
        style: TextStyle(color: Colors.white38),
      ),
    );
  }
}

------------------------------------

lib/ui/widgets/gps_status_bar.dart

import 'package:flutter/material.dart';

class GpsStatusBar extends StatelessWidget {
  const GpsStatusBar({
    super.key,
    required this.isLost,
    required this.isTracking,
  });

  final bool isLost;
  final bool isTracking;

  @override
  Widget build(BuildContext context) {
    if (!isTracking && !isLost) return const SizedBox.shrink();

    final (text, color, icon) = isLost
        ? ('GPS Signal Lost', const Color(0xFFEF5350), Icons.gps_off_rounded)
        : ('GPS Active', const Color(0xFF00E676), Icons.gps_fixed_rounded);

    return Container(
      width: double.infinity,
      padding: const EdgeInsets.symmetric(vertical: 6, horizontal: 16),
      color: color.withOpacity(0.08),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(icon, size: 13, color: color),
          const SizedBox(width: 6),
          Text(
            text,
            style: TextStyle(
              color: color,
              fontSize: 12,
              fontWeight: FontWeight.w500,
              letterSpacing: 0.5,
            ),
          ),
        ],
      ),
    );
  }
}

------------------------------------

lib/ui/widgets/speed_gauge.dart

import 'dart:math' as math;
import 'package:flutter/material.dart';

/// Animated circular speed gauge — the centrepiece of the dashboard.
class SpeedGauge extends StatelessWidget {
  const SpeedGauge({super.key, required this.speedValue, required this.unit});

  final double speedValue;
  final String unit;

  @override
  Widget build(BuildContext context) {
    final displaySpeed = speedValue.clamp(0.0, 999.0);

    return SizedBox(
      width: 260,
      height: 260,
      child: Stack(
        alignment: Alignment.center,
        children: [
          // Outer ring with arc fill
          CustomPaint(
            size: const Size(260, 260),
            painter: _ArcPainter(speedFraction: (displaySpeed / 200).clamp(0, 1)),
          ),
          // Speed number
          Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              TweenAnimationBuilder<double>(
                tween: Tween(end: displaySpeed),
                duration: const Duration(milliseconds: 400),
                curve: Curves.easeOut,
                builder: (_, value, __) => Text(
                  value.toStringAsFixed(0),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 80,
                    fontWeight: FontWeight.w200,
                    height: 1.0,
                    letterSpacing: -2,
                  ),
                ),
              ),
              const SizedBox(height: 4),
              Text(
                unit.toUpperCase(),
                style: const TextStyle(
                  color: Colors.white38,
                  fontSize: 13,
                  letterSpacing: 3,
                  fontWeight: FontWeight.w400,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

class _ArcPainter extends CustomPainter {
  const _ArcPainter({required this.speedFraction});
  final double speedFraction;

  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2 - 8;

    // Track arc
    final trackPaint = Paint()
      ..color = Colors.white10
      ..style = PaintingStyle.stroke
      ..strokeWidth = 4
      ..strokeCap = StrokeCap.round;

    const startAngle = math.pi * 0.75;
    const sweepAngle = math.pi * 1.5;

    canvas.drawArc(
      Rect.fromCircle(center: center, radius: radius),
      startAngle,
      sweepAngle,
      false,
      trackPaint,
    );

    // Fill arc
    if (speedFraction > 0) {
      final fillColor = _speedColor(speedFraction);
      final fillPaint = Paint()
        ..shader = SweepGradient(
          startAngle: startAngle,
          endAngle: startAngle + sweepAngle * speedFraction,
          colors: [fillColor.withOpacity(0.6), fillColor],
          transform: GradientRotation(startAngle),
        ).createShader(Rect.fromCircle(center: center, radius: radius))
        ..style = PaintingStyle.stroke
        ..strokeWidth = 4
        ..strokeCap = StrokeCap.round;

      canvas.drawArc(
        Rect.fromCircle(center: center, radius: radius),
        startAngle,
        sweepAngle * speedFraction,
        false,
        fillPaint,
      );
    }
  }

  Color _speedColor(double fraction) {
    if (fraction < 0.4) return const Color(0xFF00E676);   // green
    if (fraction < 0.7) return const Color(0xFFFFB74D);   // amber
    return const Color(0xFFEF5350);                        // red
  }

  @override
  bool shouldRepaint(_ArcPainter old) => old.speedFraction != speedFraction;
}

------------------------------------

lib/ui/widgets/stat_card.dart

import 'package:flutter/material.dart';

class StatCard extends StatelessWidget {
  const StatCard({
    super.key,
    required this.label,
    required this.value,
    required this.unit,
    required this.icon,
    required this.color,
    this.isTime = false,
  });

  final String label;
  final String value;
  final String unit;
  final IconData icon;
  final Color color;
  final bool isTime;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
      decoration: BoxDecoration(
        color: const Color(0xFF12121E),
        borderRadius: BorderRadius.circular(16),
        border: Border.all(color: color.withOpacity(0.2)),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(icon, size: 14, color: color.withOpacity(0.8)),
              const SizedBox(width: 6),
              Text(
                label,
                style: TextStyle(
                  color: color.withOpacity(0.7),
                  fontSize: 10,
                  fontWeight: FontWeight.w600,
                  letterSpacing: 1.2,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          isTime
              ? Text(
                  value,
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 24,
                    fontWeight: FontWeight.w300,
                    letterSpacing: 1,
                  ),
                )
              : Row(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Text(
                      value,
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 24,
                        fontWeight: FontWeight.w300,
                      ),
                    ),
                    if (unit.isNotEmpty) ...[
                      const SizedBox(width: 4),
                      Padding(
                        padding: const EdgeInsets.only(bottom: 3),
                        child: Text(
                          unit,
                          style: TextStyle(
                            color: Colors.white38,
                            fontSize: 11,
                            fontWeight: FontWeight.w400,
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
        ],
      ),
    );
  }
}

------------------------------------

------------------------------------
C:\carplay\android\app\src\main\kotlin\com\example\carplay\CarPlayApp.kt


package com.example.carplay

import androidx.car.app.CarAppService
import androidx.car.app.Screen
import androidx.car.app.Session
import androidx.car.app.model.*
import androidx.car.app.validation.HostValidator
import java.util.concurrent.atomic.AtomicReference

/**
 * Android Auto integration using the Jetpack Car App Library.
 *
 * This service receives driving data from Flutter via the static [updateDrivingData]
 * method and refreshes the car screen template every time data arrives.
 *
 * Manifest registration (see AndroidManifest.xml):
 *   <service android:name=".CarPlayAppService"
 *            android:exported="true"
 *            android:label="@string/app_name">
 *     <intent-filter>
 *       <action android:name="androidx.car.app.CarAppService"/>
 *       <category android:name="androidx.car.app.category.POI"/>  <!-- or NAVIGATION -->
 *     </intent-filter>
 *   </service>
 */
class CarPlayAppService : CarAppService() {

    override fun createHostValidator(): HostValidator = HostValidator.ALLOW_ALL_HOSTS_VALIDATOR

    override fun onCreateSession(): Session = CarPlayAppSession()

    // ── Static data store shared between Flutter bridge and Car screen ────────

    companion object {
        /** Latest snapshot of driving data, written by the Flutter platform channel. */
        internal val latestData = AtomicReference(DrivingData())

        /** Screen reference — set when the car session starts. */
        internal var activeScreen: CarPlayAppDashboardScreen? = null

        fun updateDrivingData(
            currentSpeedDisplay: String,
            averageSpeedDisplay: String,
            speedUnit: String,
            distanceDisplay: String,
            durationDisplay: String,
            tripStatus: String,
            currentSpeedKmh: Double,
            averageSpeedKmh: Double,
        ) {
            latestData.set(
                DrivingData(
                    currentSpeedDisplay = currentSpeedDisplay,
                    averageSpeedDisplay = averageSpeedDisplay,
                    speedUnit           = speedUnit,
                    distanceDisplay     = distanceDisplay,
                    durationDisplay     = durationDisplay,
                    tripStatus          = tripStatus,
                    currentSpeedKmh     = currentSpeedKmh,
                    averageSpeedKmh     = averageSpeedKmh,
                )
            )
            // Invalidate car screen so Android Auto requests a fresh template
            activeScreen?.invalidate()
        }
    }
}

// ─── Data carrier ─────────────────────────────────────────────────────────────

data class DrivingData(
    val currentSpeedDisplay: String = "0",
    val averageSpeedDisplay: String = "0",
    val speedUnit: String = "km/h",
    val distanceDisplay: String = "0 km",
    val durationDisplay: String = "00:00",
    val tripStatus: String = "idle",
    val currentSpeedKmh: Double = 0.0,
    val averageSpeedKmh: Double = 0.0,
)

// ─── Session ──────────────────────────────────────────────────────────────────

class CarPlayAppSession : Session() {
    override fun onCreateScreen(intent: android.content.Intent): Screen {
        val screen = CarPlayAppDashboardScreen(carContext)
        CarPlayAppService.activeScreen = screen
        return screen
    }
}

// ─── Car Screen ───────────────────────────────────────────────────────────────

/**
 * Renders a MessageTemplate (approved for all car categories) showing speed data.
 *
 * NOTE: Android Auto enforces strict template restrictions.
 * We use MessageTemplate as it requires no navigation permission and
 * is allowed in the POI / general category apps.
 *
 * For apps with NAVIGATION category, use NavigationTemplate for richer UI.
 */
class CarPlayAppDashboardScreen(carContext: androidx.car.app.CarContext) :
    Screen(carContext) {

    override fun onGetTemplate(): Template {
        val data = CarPlayAppService.latestData.get()

        val statusIcon = when (data.tripStatus) {
            "driving" -> CarIcon.Builder(
                androidx.core.graphics.drawable.IconCompat.createWithResource(
                    carContext, android.R.drawable.ic_media_play
                )
            ).build()
            "paused" -> CarIcon.Builder(
                androidx.core.graphics.drawable.IconCompat.createWithResource(
                    carContext, android.R.drawable.ic_media_pause
                )
            ).build()
            else -> CarIcon.Builder(
                androidx.core.graphics.drawable.IconCompat.createWithResource(
                    carContext, android.R.drawable.ic_dialog_info
                )
            ).build()
        }

        // Build a clean, large-text message template
        val title = buildSpeedTitle(data)
        val body = buildBodyText(data)

        return MessageTemplate.Builder(body)
            .setTitle(title)
            .setIcon(statusIcon)
            .setHeaderAction(Action.APP_ICON)
            .build()
    }

    private fun buildSpeedTitle(data: DrivingData): String {
        return if (data.tripStatus == "driving" || data.tripStatus == "paused") {
            "${data.currentSpeedDisplay} ${data.speedUnit}"
        } else {
            "CarPlay"
        }
    }

    private fun buildBodyText(data: DrivingData): String {
        return if (data.tripStatus == "idle" || data.tripStatus == "stopped") {
            "Open the CarPlay app on your phone to start a trip."
        } else {
            "Avg  ${data.averageSpeedDisplay} ${data.speedUnit}\n" +
            "Dist ${data.distanceDisplay}\n" +
            "Time ${data.durationDisplay}"
        }
    }
}

////////////////////////////////////

C:\carplay\android\app\src\main\kotlin\com\example\carplay\MainActivity.kt


package com.example.carplay
import android.os.Bundle
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel

/**
 * MainActivity wires the Flutter MethodChannel to the Android Auto service.
 * All GPS work is done in Flutter/Dart; this class only forwards display data.
 */
class MainActivity : FlutterActivity() {

    private val channelName = "com.example.carplay/car_display"

    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)

        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, channelName)
            .setMethodCallHandler { call, result ->
                when (call.method) {
                    "updateDisplay" -> {
                        val data = call.arguments as? Map<*, *>
                        if (data != null) {
                            // Forward to Android Auto service via a local broadcast
                            CarPlayAppService.updateDrivingData(
                                currentSpeedDisplay = data["currentSpeedDisplay"] as? String ?: "0",
                                averageSpeedDisplay = data["averageSpeedDisplay"] as? String ?: "0",
                                speedUnit           = data["speedUnit"]           as? String ?: "km/h",
                                distanceDisplay     = data["distanceDisplay"]     as? String ?: "0 km",
                                durationDisplay     = data["durationDisplay"]     as? String ?: "00:00",
                                tripStatus          = data["tripStatus"]          as? String ?: "idle",
                                currentSpeedKmh     = (data["currentSpeedKmh"]   as? Double) ?: 0.0,
                                averageSpeedKmh     = (data["averageSpeedKmh"]   as? Double) ?: 0.0,
                            )
                            result.success(null)
                        } else {
                            result.error("INVALID_ARGS", "Expected Map argument", null)
                        }
                    }
                    else -> result.notImplemented()
                }
            }
    }
}
